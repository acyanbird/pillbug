import {
  ACESFilmicToneMapping,
  AmbientLight,
  BackSide,
  BoxGeometry,
  CineonToneMapping,
  Color,
  CubeCamera,
  DataArrayTexture,
  DepthFormat,
  DepthTexture,
  DirectionalLight,
  DynamicDrawUsage,
  EventDispatcher,
  FileLoader,
  Float16BufferAttribute,
  FloatType,
  FramebufferTexture,
  HemisphereLight,
  InstancedInterleavedBuffer,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  LessCompare,
  LineBasicMaterial,
  LineDashedMaterial,
  LinearEncoding,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearSRGBColorSpace,
  LinearToneMapping,
  Loader,
  Material,
  MaterialLoader,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  NearestFilter,
  NearestMipmapNearestFilter,
  NoBlending,
  NoColorSpace,
  NoToneMapping,
  ObjectLoader,
  ObjectSpaceNormalMap,
  PointLight,
  PointsMaterial,
  REVISION,
  ReinhardToneMapping,
  RenderTarget,
  SRGBColorSpace,
  Scene,
  ShaderMaterial,
  SpotLight,
  SpriteMaterial,
  StaticDrawUsage,
  TangentSpaceNormalMap,
  UnsignedIntType,
  Vector2,
  Vector3,
  Vector4,
  WebGLCubeRenderTarget,
  WebGPUCoordinateSystem,
  sRGBEncoding
} from "./chunk-R3I2WUGT.js";
import {
  __export
} from "./chunk-P2LSHJDD.js";

// node_modules/three/examples/jsm/nodes/core/constants.js
var NodeShaderStage = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
};
var NodeUpdateType = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
};
var NodeType = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
};
var defaultShaderStages = ["fragment", "vertex"];
var defaultBuildStages = ["setup", "analyze", "generate"];
var shaderStages = [...defaultShaderStages, "compute"];
var vectorComponents = ["x", "y", "z", "w"];

// node_modules/three/examples/jsm/nodes/core/NodeUtils.js
var NodeUtils_exports = {};
__export(NodeUtils_exports, {
  arrayBufferToBase64: () => arrayBufferToBase64,
  base64ToArrayBuffer: () => base64ToArrayBuffer,
  getCacheKey: () => getCacheKey,
  getNodeChildren: () => getNodeChildren,
  getValueFromType: () => getValueFromType,
  getValueType: () => getValueType
});
function getCacheKey(object) {
  let cacheKey = "{";
  if (object.isNode === true) {
    cacheKey += object.id;
  }
  for (const { property: property2, childNode } of getNodeChildren(object)) {
    cacheKey += "," + property2.slice(0, -4) + ":" + childNode.getCacheKey();
  }
  cacheKey += "}";
  return cacheKey;
}
function* getNodeChildren(node, toJSON = false) {
  for (const property2 in node) {
    if (property2.startsWith("_") === true)
      continue;
    const object = node[property2];
    if (Array.isArray(object) === true) {
      for (let i = 0; i < object.length; i++) {
        const child = object[i];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property2, index: i, childNode: child };
        }
      }
    } else if (object && object.isNode === true) {
      yield { property: property2, childNode: object };
    } else if (typeof object === "object") {
      for (const subProperty in object) {
        const child = object[subProperty];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property2, index: subProperty, childNode: child };
        }
      }
    }
  }
}
function getValueType(value) {
  if (value === void 0 || value === null)
    return null;
  const typeOf = typeof value;
  if (value.isNode === true) {
    return "node";
  } else if (typeOf === "number") {
    return "float";
  } else if (typeOf === "boolean") {
    return "bool";
  } else if (typeOf === "string") {
    return "string";
  } else if (typeOf === "function") {
    return "shader";
  } else if (value.isVector2 === true) {
    return "vec2";
  } else if (value.isVector3 === true) {
    return "vec3";
  } else if (value.isVector4 === true) {
    return "vec4";
  } else if (value.isMatrix3 === true) {
    return "mat3";
  } else if (value.isMatrix4 === true) {
    return "mat4";
  } else if (value.isColor === true) {
    return "color";
  } else if (value instanceof ArrayBuffer) {
    return "ArrayBuffer";
  }
  return null;
}
function getValueFromType(type, ...params) {
  const last4 = type ? type.slice(-4) : void 0;
  if (params.length === 1) {
    if (last4 === "vec2")
      params = [params[0], params[0]];
    else if (last4 === "vec3")
      params = [params[0], params[0], params[0]];
    else if (last4 === "vec4")
      params = [params[0], params[0], params[0], params[0]];
  }
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return params[0] || false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return params[0] || 0;
  } else if (type === "string") {
    return params[0] || "";
  } else if (type === "ArrayBuffer") {
    return base64ToArrayBuffer(params[0]);
  }
  return null;
}
function arrayBufferToBase64(arrayBuffer2) {
  let chars = "";
  const array = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array.length; i++) {
    chars += String.fromCharCode(array[i]);
  }
  return btoa(chars);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;
}

// node_modules/three/examples/jsm/nodes/core/Node.js
var NodeClasses = /* @__PURE__ */ new Map();
var _nodeId = 0;
var Node = class extends EventDispatcher {
  constructor(nodeType = null) {
    super();
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.NONE;
    this.updateBeforeType = NodeUpdateType.NONE;
    this.uuid = MathUtils.generateUUID();
    this.isNode = true;
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  get type() {
    return this.constructor.type;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return false;
  }
  *getChildren() {
    for (const { childNode } of getNodeChildren(this)) {
      yield childNode;
    }
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(callback) {
    callback(this);
    for (const childNode of this.getChildren()) {
      childNode.traverse(callback);
    }
  }
  getCacheKey() {
    return getCacheKey(this);
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getNodeType(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    if (nodeProperties.outputNode) {
      return nodeProperties.outputNode.getNodeType(builder);
    }
    return this.nodeType;
  }
  getShared(builder) {
    const hash2 = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash2);
    return nodeFromHash || this;
  }
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    for (const childNode of this.getChildren()) {
      nodeProperties["_node" + childNode.id] = childNode;
    }
    return null;
  }
  construct(builder) {
    console.warn("THREE.Node: construct() is deprecated. Use setup() instead.");
    return this.setup(builder);
  }
  analyze(builder) {
    const nodeData = builder.getDataFromNode(this);
    nodeData.dependenciesCount = nodeData.dependenciesCount === void 0 ? 1 : nodeData.dependenciesCount + 1;
    if (nodeData.dependenciesCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if (childNode && childNode.isNode === true) {
          childNode.build(builder);
        }
      }
    }
  }
  generate(builder, output2) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode && outputNode.isNode === true) {
      return outputNode.build(builder, output2);
    }
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(builder, output2 = null) {
    const refNode = this.getShared(builder);
    if (this !== refNode) {
      return refNode.build(builder, output2);
    }
    builder.addNode(this);
    builder.addChain(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "setup") {
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true || builder.context.tempRead === false) {
        const stackNodesBeforeSetup = builder.stack.nodes.length;
        properties.initialized = true;
        properties.outputNode = this.setup(builder);
        if (properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup) {
          properties.outputNode = builder.stack;
        }
        for (const childNode of Object.values(properties)) {
          if (childNode && childNode.isNode === true) {
            childNode.build(builder);
          }
        }
      }
    } else if (buildStage === "analyze") {
      this.analyze(builder);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length === 1;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData = builder.getDataFromNode(this);
        result = nodeData.snippet;
        if (result === void 0) {
          result = this.generate(builder) || "";
          nodeData.snippet = result;
        }
        result = builder.format(result, type, output2);
      } else {
        result = this.generate(builder, output2) || "";
      }
    }
    builder.removeChain(this);
    return result;
  }
  getSerializeChildren() {
    return getNodeChildren(this);
  }
  serialize(json) {
    const nodeChildren = this.getSerializeChildren();
    const inputNodes = {};
    for (const { property: property2, index, childNode } of nodeChildren) {
      if (index !== void 0) {
        if (inputNodes[property2] === void 0) {
          inputNodes[property2] = Number.isInteger(index) ? [] : {};
        }
        inputNodes[property2][index] = childNode.toJSON(json.meta).uuid;
      } else {
        inputNodes[property2] = childNode.toJSON(json.meta).uuid;
      }
    }
    if (Object.keys(inputNodes).length > 0) {
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        if (Array.isArray(json.inputNodes[property2])) {
          const inputArray = [];
          for (const uuid of json.inputNodes[property2]) {
            inputArray.push(nodes[uuid]);
          }
          this[property2] = inputArray;
        } else if (typeof json.inputNodes[property2] === "object") {
          const inputObject = {};
          for (const subProperty in json.inputNodes[property2]) {
            const uuid = json.inputNodes[property2][subProperty];
            inputObject[subProperty] = nodes[uuid];
          }
          this[property2] = inputObject;
        } else {
          const uuid = json.inputNodes[property2];
          this[property2] = nodes[uuid];
        }
      }
    }
  }
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.6,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      if (isRoot !== true)
        meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
var Node_default = Node;
function addNodeClass(type, nodeClass) {
  if (typeof nodeClass !== "function" || !type)
    throw new Error(`Node class ${type} is not a class`);
  if (NodeClasses.has(type))
    throw new Error(`Redefinition of node class ${type}`);
  NodeClasses.set(type, nodeClass);
  nodeClass.type = type;
}
function createNodeFromType(type) {
  const Class = NodeClasses.get(type);
  if (Class !== void 0) {
    return new Class();
  }
}

// node_modules/three/examples/jsm/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
    this.precision = null;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value;
    if (this.value && this.value.toArray)
      data.value = this.value.toArray();
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
    if (data.valueType === "ArrayBuffer")
      data.value = arrayBufferToBase64(data.value);
    data.precision = this.precision;
  }
  deserialize(data) {
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
    this.precision = data.precision || null;
    if (this.value && this.value.fromArray)
      this.value = this.value.fromArray(data.value);
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var InputNode_default = InputNode;
addNodeClass("InputNode", InputNode);

// node_modules/three/examples/jsm/nodes/core/UniformGroupNode.js
var UniformGroupNode = class extends Node_default {
  constructor(name, shared = false) {
    super("string");
    this.name = name;
    this.version = 0;
    this.shared = shared;
    this.isUniformGroup = true;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
};
var uniformGroup = (name) => new UniformGroupNode(name);
var sharedUniformGroup = (name) => new UniformGroupNode(name, true);
var frameGroup = sharedUniformGroup("frame");
var renderGroup = sharedUniformGroup("render");
var objectGroup = uniformGroup("object");
var UniformGroupNode_default = UniformGroupNode;
addNodeClass("UniformGroupNode", UniformGroupNode);

// node_modules/three/examples/jsm/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
    this.isArrayElementNode = true;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;
addNodeClass("ArrayElementNode", ArrayElementNode);

// node_modules/three/examples/jsm/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType(builder) {
    const requestType = this.node.getNodeType(builder);
    let convertTo = null;
    for (const overloadingType of this.convertTo.split("|")) {
      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
        convertTo = overloadingType;
      }
    }
    return convertTo;
  }
  serialize(data) {
    super.serialize(data);
    data.convertTo = this.convertTo;
  }
  deserialize(data) {
    super.deserialize(data);
    this.convertTo = data.convertTo;
  }
  generate(builder, output2) {
    const node = this.node;
    const type = this.getNodeType(builder);
    const snippet = node.build(builder, type);
    return builder.format(snippet, type, output2);
  }
};
var ConvertNode_default = ConvertNode;
addNodeClass("ConvertNode", ConvertNode);

// node_modules/three/examples/jsm/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type) {
    super(type);
    this.isTempNode = true;
  }
  hasDependencies(builder) {
    return builder.getDataFromNode(this).dependenciesCount > 1;
  }
  build(builder, output2) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output2));
      const nodeData = builder.getDataFromNode(this);
      if (builder.context.tempRead !== false && nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output2);
      } else if (builder.context.tempWrite !== false && type !== "void" && output2 !== "void" && this.hasDependencies(builder)) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, null, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output2);
      }
    }
    return super.build(builder, output2);
  }
};
var TempNode_default = TempNode;
addNodeClass("TempNode", TempNode);

// node_modules/three/examples/jsm/nodes/utils/JoinNode.js
var JoinNode = class extends TempNode_default {
  constructor(nodes = [], nodeType = null) {
    super(nodeType);
    this.nodes = nodes;
  }
  getNodeType(builder) {
    if (this.nodeType !== null) {
      return builder.getVectorType(this.nodeType);
    }
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const nodes = this.nodes;
    const primitiveType = builder.getPrimitiveType(type);
    const snippetValues = [];
    for (const input of nodes) {
      let inputSnippet = input.build(builder);
      const inputPrimitiveType = builder.getPrimitiveType(input.getNodeType(builder));
      if (inputPrimitiveType !== primitiveType) {
        inputSnippet = builder.format(inputSnippet, inputPrimitiveType, primitiveType);
      }
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output2);
  }
};
var JoinNode_default = JoinNode;
addNodeClass("JoinNode", JoinNode);

// node_modules/three/examples/jsm/nodes/utils/SplitNode.js
var stringVectorComponents = vectorComponents.join("");
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
    this.isSplitNode = true;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length);
  }
  generate(builder, output2) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength());
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output2);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output2);
      }
    } else {
      snippet = node.build(builder, output2);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;
addNodeClass("SplitNode", SplitNode);

// node_modules/three/examples/jsm/nodes/utils/SetNode.js
var SetNode = class extends TempNode_default {
  constructor(sourceNode, components, targetNode) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
    this.targetNode = targetNode;
  }
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { sourceNode, components, targetNode } = this;
    const sourceType = this.getNodeType(builder);
    const targetType = builder.getTypeFromLength(components.length);
    const targetSnippet = targetNode.build(builder, targetType);
    const sourceSnippet = sourceNode.build(builder, sourceType);
    const length2 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    for (let i = 0; i < length2; i++) {
      const component = vectorComponents[i];
      if (component === components[0]) {
        snippetValues.push(targetSnippet);
        i += components.length - 1;
      } else {
        snippetValues.push(sourceSnippet + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
};
var SetNode_default = SetNode;
addNodeClass("SetNode", SetNode);

// node_modules/three/examples/jsm/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  generateConst(builder) {
    return builder.generateConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type, output2);
  }
};
var ConstNode_default = ConstNode;
addNodeClass("ConstNode", ConstNode);

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js
var currentStack = null;
var NodeElements = /* @__PURE__ */ new Map();
function addNodeElement(name, nodeElement) {
  if (NodeElements.has(name))
    throw new Error(`Redefinition of node element ${name}`);
  if (typeof nodeElement !== "function")
    throw new Error(`Node element ${name} is not a function`);
  NodeElements.set(name, nodeElement);
}
var parseSwizzle = (props) => props.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
var shaderNodeHandler = {
  setup(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get(node, prop, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (node.isStackNode !== true && prop === "assign") {
        return (...params) => currentStack.assign(nodeObj, ...params);
      } else if (NodeElements.has(prop)) {
        const nodeElement = NodeElements.get(prop);
        return node.isStackNode ? (...params) => nodeObj.add(nodeElement(...params)) : (...params) => nodeElement(nodeObj, ...params);
      } else if (prop === "self") {
        return node;
      } else if (prop.endsWith("Assign") && NodeElements.has(prop.slice(0, prop.length - "Assign".length))) {
        const nodeElement = NodeElements.get(prop.slice(0, prop.length - "Assign".length));
        return node.isStackNode ? (...params) => nodeObj.assign(params[0], nodeElement(...params)) : (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));
      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = parseSwizzle(prop);
        return nodeObject(new SplitNode_default(nodeObj, prop));
      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
        prop = parseSwizzle(prop.slice(3).toLowerCase());
        prop = prop.split("").sort().join("");
        return (value) => nodeObject(new SetNode_default(node, prop, value));
      } else if (prop === "width" || prop === "height" || prop === "depth") {
        if (prop === "width")
          prop = "x";
        else if (prop === "height")
          prop = "y";
        else if (prop === "depth")
          prop = "z";
        return nodeObject(new SplitNode_default(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(new ArrayElementNode_default(nodeObj, new ConstNode_default(Number(prop), "uint")));
      }
    }
    return Reflect.get(node, prop, nodeObj);
  },
  set(node, prop, value, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true || prop === "width" || prop === "height" || prop === "depth" || /^\d+$/.test(prop) === true) {
        nodeObj[prop].assign(value);
        return true;
      }
    }
    return Reflect.set(node, prop, value, nodeObj);
  }
};
var nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
var nodeBuilderFunctionsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj, altType = null) {
  const type = getValueType(obj);
  if (type === "node") {
    let nodeObject2 = nodeObjectsCacheMap.get(obj);
    if (nodeObject2 === void 0) {
      nodeObject2 = new Proxy(obj, shaderNodeHandler);
      nodeObjectsCacheMap.set(obj, nodeObject2);
      nodeObjectsCacheMap.set(nodeObject2, nodeObject2);
    }
    return nodeObject2;
  } else if (altType === null && (type === "float" || type === "boolean") || type && type !== "shader" && type !== "string") {
    return nodeObject(getConstNode(obj, altType));
  } else if (type === "shader") {
    return tslFn(obj);
  }
  return obj;
};
var ShaderNodeObjects = function(objects, altType = null) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name], altType);
  }
  return objects;
};
var ShaderNodeArray = function(array, altType = null) {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = nodeObject(array[i], altType);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = null) {
  const assignNode = (node) => nodeObject(settings !== null ? Object.assign(node, settings) : node);
  if (scope === null) {
    return (...params) => {
      return assignNode(new NodeClass(...nodeArray(params)));
    };
  } else if (factor !== null) {
    factor = nodeObject(factor);
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));
    };
  } else {
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params)));
    };
  }
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
var ShaderCallNodeInternal = class extends Node_default {
  constructor(shaderNode, inputNodes) {
    super();
    this.shaderNode = shaderNode;
    this.inputNodes = inputNodes;
  }
  getNodeType(builder) {
    const { outputNode } = builder.getNodeProperties(this);
    return outputNode ? outputNode.getNodeType(builder) : super.getNodeType(builder);
  }
  call(builder) {
    const { shaderNode, inputNodes } = this;
    if (shaderNode.layout) {
      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);
      if (functionNodesCacheMap === void 0) {
        functionNodesCacheMap = /* @__PURE__ */ new WeakMap();
        nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);
      }
      let functionNode = functionNodesCacheMap.get(shaderNode);
      if (functionNode === void 0) {
        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));
        functionNodesCacheMap.set(shaderNode, functionNode);
      }
      return nodeObject(functionNode.call(inputNodes));
    }
    const jsFunc = shaderNode.jsFunc;
    const outputNode = inputNodes !== null ? jsFunc(inputNodes, builder.stack, builder) : jsFunc(builder.stack, builder);
    return nodeObject(outputNode);
  }
  setup(builder) {
    builder.addStack();
    builder.stack.outputNode = this.call(builder);
    return builder.removeStack();
  }
  generate(builder, output2) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode === null) {
      return this.call(builder).build(builder, output2);
    }
    return super.generate(builder, output2);
  }
};
var ShaderNodeInternal = class extends Node_default {
  constructor(jsFunc) {
    super();
    this.jsFunc = jsFunc;
    this.layout = null;
  }
  get isArrayInput() {
    return /^\(\s+?\[/.test(this.jsFunc.toString());
  }
  setLayout(layout) {
    this.layout = layout;
    return this;
  }
  call(inputs = null) {
    nodeObjects(inputs);
    return nodeObject(new ShaderCallNodeInternal(this, inputs));
  }
  setup() {
    return this.call();
  }
};
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (const int2 of ints)
  intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (const float2 of floats)
  floatsCacheMap.set(float2, new ConstNode_default(float2));
for (const float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getConstNode = (value, type) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value, type);
  }
};
var safeGetNodeType = (node) => {
  try {
    return node.getNodeType();
  } catch (_) {
    return void 0;
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0 || !["bool", "float", "int", "uint"].includes(type) && params.every((param) => typeof param !== "object")) {
      params = [getValueFromType(type, ...params)];
    }
    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
      return nodeObject(cacheMap.get(params[0]));
    }
    if (params.length === 1) {
      const node = getConstNode(params[0], type);
      if (safeGetNodeType(node) === type)
        return nodeObject(node);
      return nodeObject(new ConvertNode_default(node, type));
    }
    const nodes = params.map((param) => getConstNode(param));
    return nodeObject(new JoinNode_default(nodes, type));
  };
};
var getConstNodeType = (value) => value !== void 0 && value !== null ? value.nodeType || value.convertTo || (typeof value === "string" ? value : null) : null;
function ShaderNode(jsFunc) {
  return new Proxy(new ShaderNodeInternal(jsFunc), shaderNodeHandler);
}
var nodeObject = (val, altType = null) => (
  /* new */
  ShaderNodeObject(val, altType)
);
var nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
var nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
var nodeProxy = (...params) => new ShaderNodeProxy(...params);
var nodeImmutable = (...params) => new ShaderNodeImmutable(...params);
var shader = (jsFunc) => {
  console.warn("TSL: shader() is deprecated. Use tslFn() instead.");
  return new ShaderNode(jsFunc);
};
var tslFn = (jsFunc) => {
  const shaderNode = new ShaderNode(jsFunc);
  const fn = (...params) => {
    let inputs;
    nodeObjects(params);
    if (params[0] && params[0].isNode) {
      inputs = [...params];
    } else {
      inputs = params[0];
    }
    return shaderNode.call(inputs);
  };
  fn.shaderNode = shaderNode;
  fn.setLayout = (layout) => {
    shaderNode.setLayout(layout);
    return fn;
  };
  return fn;
};
addNodeClass("ShaderNode", ShaderNode);
var setCurrentStack = (stack2) => currentStack = stack2;
var getCurrentStack = () => currentStack;
var If = (...params) => currentStack.if(...params);
function append(node) {
  if (currentStack)
    currentStack.add(node);
  return node;
}
addNodeElement("append", append);
var color = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.int);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
var string = (value = "") => nodeObject(new ConstNode_default(value, "string"));
var arrayBuffer = (value) => nodeObject(new ConstNode_default(value, "ArrayBuffer"));
addNodeElement("color", color);
addNodeElement("float", float);
addNodeElement("int", int);
addNodeElement("uint", uint);
addNodeElement("bool", bool);
addNodeElement("vec2", vec2);
addNodeElement("ivec2", ivec2);
addNodeElement("uvec2", uvec2);
addNodeElement("bvec2", bvec2);
addNodeElement("vec3", vec3);
addNodeElement("ivec3", ivec3);
addNodeElement("uvec3", uvec3);
addNodeElement("bvec3", bvec3);
addNodeElement("vec4", vec4);
addNodeElement("ivec4", ivec4);
addNodeElement("uvec4", uvec4);
addNodeElement("bvec4", bvec4);
addNodeElement("mat3", mat3);
addNodeElement("imat3", imat3);
addNodeElement("umat3", umat3);
addNodeElement("bmat3", bmat3);
addNodeElement("mat4", mat4);
addNodeElement("imat4", imat4);
addNodeElement("umat4", umat4);
addNodeElement("bmat4", bmat4);
addNodeElement("string", string);
addNodeElement("arrayBuffer", arrayBuffer);
var element = nodeProxy(ArrayElementNode_default);
var convert = (node, types) => nodeObject(new ConvertNode_default(nodeObject(node), types));
var split = (node, channels) => nodeObject(new SplitNode_default(nodeObject(node), channels));
addNodeElement("element", element);
addNodeElement("convert", convert);

// node_modules/three/examples/jsm/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
    this.groupNode = objectGroup;
  }
  setGroup(group) {
    this.groupNode = group;
    return this;
  }
  getGroup() {
    return this.groupNode;
  }
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const hash2 = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash2);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash2);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, builder.context.label);
    const propertyName = builder.getPropertyName(nodeUniform);
    if (builder.context.label !== void 0)
      delete builder.context.label;
    return builder.format(propertyName, type, output2);
  }
};
var UniformNode_default = UniformNode;
var uniform = (arg1, arg2) => {
  const nodeType = getConstNodeType(arg2 || arg1);
  const value = arg1 && arg1.isNode === true ? arg1.node && arg1.node.value || arg1.value : arg1;
  return nodeObject(new UniformNode(value, nodeType));
};
addNodeClass("UniformNode", UniformNode);

// node_modules/three/examples/jsm/nodes/core/ArrayUniformNode.js
var ArrayUniformNode = class extends UniformNode_default {
  constructor(nodes = []) {
    super();
    this.isArrayUniformNode = true;
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return this.nodes[0].getNodeType(builder);
  }
};
var ArrayUniformNode_default = ArrayUniformNode;
addNodeClass("ArrayUniformNode", ArrayUniformNode);

// node_modules/three/examples/jsm/nodes/core/AssignNode.js
var AssignNode = class extends TempNode_default {
  constructor(targetNode, sourceNode) {
    super();
    this.targetNode = targetNode;
    this.sourceNode = sourceNode;
  }
  hasDependencies() {
    return false;
  }
  getNodeType(builder, output2) {
    return output2 !== "void" ? this.targetNode.getNodeType(builder) : "void";
  }
  generate(builder, output2) {
    const targetNode = this.targetNode;
    const sourceNode = this.sourceNode;
    const targetType = targetNode.getNodeType(builder);
    const target = targetNode.build(builder);
    const source = sourceNode.build(builder, targetType);
    const snippet = `${target} = ${source}`;
    if (output2 === "void") {
      builder.addLineFlowCode(snippet);
      return;
    } else {
      const sourceType = sourceNode.getNodeType(builder);
      if (sourceType === "void") {
        builder.addLineFlowCode(snippet);
        return target;
      }
      return builder.format(snippet, targetType, output2);
    }
  }
};
var AssignNode_default = AssignNode;
var assign = nodeProxy(AssignNode);
addNodeClass("AssignNode", AssignNode);
addNodeElement("assign", assign);

// node_modules/three/examples/jsm/nodes/core/VaryingNode.js
var VaryingNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.isVaryingNode = true;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const { name, node } = this;
    const type = this.getNodeType(builder);
    const nodeVarying = builder.getVaryingFromNode(this, name, type);
    nodeVarying.needsInterpolation || (nodeVarying.needsInterpolation = builder.shaderStage === "fragment");
    const propertyName = builder.getPropertyName(nodeVarying, NodeShaderStage.VERTEX);
    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, node, type, propertyName);
    return builder.getPropertyName(nodeVarying);
  }
};
var VaryingNode_default = VaryingNode;
var varying = nodeProxy(VaryingNode);
addNodeElement("varying", varying);
addNodeClass("VaryingNode", VaryingNode);

// node_modules/three/examples/jsm/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType = null) {
    super(nodeType);
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    let nodeType = super.getNodeType(builder);
    if (nodeType === null) {
      const attributeName = this.getAttributeName(builder);
      if (builder.hasGeometryAttribute(attributeName)) {
        const attribute2 = builder.geometry.getAttribute(attributeName);
        nodeType = builder.getTypeFromAttribute(attribute2);
      } else {
        nodeType = "float";
      }
    }
    return nodeType;
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const nodeType = this.getNodeType(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    if (geometryAttribute === true) {
      const attribute2 = builder.geometry.getAttribute(attributeName);
      const attributeType = builder.getTypeFromAttribute(attribute2);
      const nodeAttribute = builder.getAttribute(attributeName, attributeType);
      if (builder.shaderStage === "vertex") {
        return builder.format(nodeAttribute.name, attributeType, nodeType);
      } else {
        const nodeVarying = varying(this);
        return nodeVarying.build(builder, nodeType);
      }
    } else {
      console.warn(`AttributeNode: Attribute "${attributeName}" not found.`);
      return builder.generateConst(nodeType);
    }
  }
};
var AttributeNode_default = AttributeNode;
var attribute = (name, nodeType) => nodeObject(new AttributeNode(name, nodeType));
addNodeClass("AttributeNode", AttributeNode);

// node_modules/three/examples/jsm/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addLineFlowCode(snippet);
    }
    return this.outputNode.build(builder);
  }
};
var BypassNode_default = BypassNode;
var bypass = nodeProxy(BypassNode);
addNodeElement("bypass", bypass);
addNodeClass("BypassNode", BypassNode);

// node_modules/three/examples/jsm/nodes/core/NodeCache.js
var id = 0;
var NodeCache = class {
  constructor() {
    this.id = id++;
    this.nodesData = /* @__PURE__ */ new WeakMap();
  }
  getNodeData(node) {
    return this.nodesData.get(node);
  }
  setNodeData(node, data) {
    this.nodesData.set(node, data);
  }
};
var NodeCache_default = NodeCache;

// node_modules/three/examples/jsm/nodes/core/CacheNode.js
var CacheNode = class extends Node_default {
  constructor(node, cache2 = new NodeCache_default()) {
    super();
    this.isCacheNode = true;
    this.node = node;
    this.cache = cache2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  build(builder, ...params) {
    const previousCache = builder.getCache();
    builder.setCache(this.cache);
    const data = this.node.build(builder, ...params);
    builder.setCache(previousCache);
    return data;
  }
};
var CacheNode_default = CacheNode;
var cache = nodeProxy(CacheNode);
addNodeElement("cache", cache);
addNodeClass("CacheNode", CacheNode);

// node_modules/three/examples/jsm/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context2 = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.context = context2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  setup(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const node = this.node.build(builder);
    builder.setContext(previousContext);
    return node;
  }
  generate(builder, output2) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const snippet = this.node.build(builder, output2);
    builder.setContext(previousContext);
    return snippet;
  }
};
var ContextNode_default = ContextNode;
var context = nodeProxy(ContextNode);
var label = (node, name) => context(node, { label: name });
addNodeElement("context", context);
addNodeElement("label", label);
addNodeClass("ContextNode", ContextNode);

// node_modules/three/examples/jsm/nodes/core/IndexNode.js
var IndexNode = class _IndexNode extends Node_default {
  constructor(scope) {
    super("uint");
    this.scope = scope;
    this.isInstanceIndexNode = true;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const scope = this.scope;
    let propertyName;
    if (scope === _IndexNode.VERTEX) {
      propertyName = builder.getVertexIndex();
    } else if (scope === _IndexNode.INSTANCE) {
      propertyName = builder.getInstanceIndex();
    } else {
      throw new Error("THREE.IndexNode: Unknown scope: " + scope);
    }
    let output2;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
};
IndexNode.VERTEX = "vertex";
IndexNode.INSTANCE = "instance";
var IndexNode_default = IndexNode;
var vertexIndex = nodeImmutable(IndexNode, IndexNode.VERTEX);
var instanceIndex = nodeImmutable(IndexNode, IndexNode.INSTANCE);
addNodeClass("IndexNode", IndexNode);

// node_modules/three/examples/jsm/nodes/core/LightingModel.js
var LightingModel = class {
  start() {
  }
  finish() {
  }
  direct() {
  }
  indirectDiffuse() {
  }
  indirectSpecular() {
  }
  ambientOcclusion() {
  }
};
var LightingModel_default = LightingModel;

// node_modules/three/examples/jsm/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const { node, name } = this;
    const nodeVar = builder.getVarFromNode(this, name, builder.getVectorType(this.getNodeType(builder)));
    const propertyName = builder.getPropertyName(nodeVar);
    const snippet = node.build(builder, nodeVar.type);
    builder.addLineFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
var VarNode_default = VarNode;
var temp = nodeProxy(VarNode);
addNodeElement("temp", temp);
addNodeElement("toVar", (...params) => temp(...params).append());
addNodeClass("VarNode", VarNode);

// node_modules/three/examples/jsm/nodes/core/NodeAttribute.js
var NodeAttribute = class {
  constructor(name, type, node = null) {
    this.isNodeAttribute = true;
    this.name = name;
    this.type = type;
    this.node = node;
  }
};
var NodeAttribute_default = NodeAttribute;

// node_modules/three/examples/jsm/nodes/core/NodeUniform.js
var NodeUniform = class {
  constructor(name, type, node, needsUpdate = void 0) {
    this.isNodeUniform = true;
    this.name = name;
    this.type = type;
    this.node = node.getSelf();
    this.needsUpdate = needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
  get id() {
    return this.node.id;
  }
  get groupNode() {
    return this.node.groupNode;
  }
};
var NodeUniform_default = NodeUniform;

// node_modules/three/examples/jsm/nodes/core/NodeVar.js
var NodeVar = class {
  constructor(name, type) {
    this.isNodeVar = true;
    this.name = name;
    this.type = type;
  }
};
var NodeVar_default = NodeVar;

// node_modules/three/examples/jsm/nodes/core/NodeVarying.js
var NodeVarying = class extends NodeVar_default {
  constructor(name, type) {
    super(name, type);
    this.needsInterpolation = false;
    this.isNodeVarying = true;
  }
};
var NodeVarying_default = NodeVarying;

// node_modules/three/examples/jsm/nodes/core/NodeCode.js
var NodeCode = class {
  constructor(name, type, code2 = "") {
    this.name = name;
    this.type = type;
    this.code = code2;
    Object.defineProperty(this, "isNodeCode", { value: true });
  }
};
var NodeCode_default = NodeCode;

// node_modules/three/examples/jsm/nodes/core/NodeKeywords.js
var NodeKeywords = class {
  constructor() {
    this.keywords = [];
    this.nodes = [];
    this.keywordsCallback = {};
  }
  getNode(name) {
    let node = this.nodes[name];
    if (node === void 0 && this.keywordsCallback[name] !== void 0) {
      node = this.keywordsCallback[name](name);
      this.nodes[name] = node;
    }
    return node;
  }
  addKeyword(name, callback) {
    this.keywords.push(name);
    this.keywordsCallback[name] = callback;
    return this;
  }
  parse(code2) {
    const keywordNames = this.keywords;
    const regExp = new RegExp(`\\b${keywordNames.join("\\b|\\b")}\\b`, "g");
    const codeKeywords = code2.match(regExp);
    const keywordNodes = [];
    if (codeKeywords !== null) {
      for (const keyword of codeKeywords) {
        const node = this.getNode(keyword);
        if (node !== void 0 && keywordNodes.indexOf(node) === -1) {
          keywordNodes.push(node);
        }
      }
    }
    return keywordNodes;
  }
  include(builder, code2) {
    const keywordNodes = this.parse(code2);
    for (const keywordNode of keywordNodes) {
      keywordNode.build(builder);
    }
  }
};
var NodeKeywords_default = NodeKeywords;

// node_modules/three/examples/jsm/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(nodeType, name = null, varying2 = false) {
    super(nodeType);
    this.name = name;
    this.varying = varying2;
    this.isPropertyNode = true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  isGlobal() {
    return true;
  }
  generate(builder) {
    let nodeVar;
    if (this.varying === true) {
      nodeVar = builder.getVaryingFromNode(this, this.name);
      nodeVar.needsInterpolation = true;
    } else {
      nodeVar = builder.getVarFromNode(this, this.name);
    }
    return builder.getPropertyName(nodeVar);
  }
};
var PropertyNode_default = PropertyNode;
var property = (type, name) => nodeObject(new PropertyNode(type, name));
var varyingProperty = (type, name) => nodeObject(new PropertyNode(type, name, true));
var diffuseColor = nodeImmutable(PropertyNode, "vec4", "DiffuseColor");
var roughness = nodeImmutable(PropertyNode, "float", "Roughness");
var metalness = nodeImmutable(PropertyNode, "float", "Metalness");
var clearcoat = nodeImmutable(PropertyNode, "float", "Clearcoat");
var clearcoatRoughness = nodeImmutable(PropertyNode, "float", "ClearcoatRoughness");
var sheen = nodeImmutable(PropertyNode, "vec3", "Sheen");
var sheenRoughness = nodeImmutable(PropertyNode, "float", "SheenRoughness");
var iridescence = nodeImmutable(PropertyNode, "float", "Iridescence");
var iridescenceIOR = nodeImmutable(PropertyNode, "float", "IridescenceIOR");
var iridescenceThickness = nodeImmutable(PropertyNode, "float", "IridescenceThickness");
var specularColor = nodeImmutable(PropertyNode, "color", "SpecularColor");
var shininess = nodeImmutable(PropertyNode, "float", "Shininess");
var output = nodeImmutable(PropertyNode, "vec4", "Output");
var dashSize = nodeImmutable(PropertyNode, "float", "dashSize");
var gapSize = nodeImmutable(PropertyNode, "float", "gapSize");
var pointWidth = nodeImmutable(PropertyNode, "float", "pointWidth");
addNodeClass("PropertyNode", PropertyNode);

// node_modules/three/examples/jsm/nodes/core/ParameterNode.js
var ParameterNode = class extends PropertyNode_default {
  constructor(nodeType, name = null) {
    super(nodeType, name);
    this.isParameterNode = true;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
};
var ParameterNode_default = ParameterNode;
var parameter = (type, name) => nodeObject(new ParameterNode(type, name));
addNodeClass("ParameterNode", ParameterNode);

// node_modules/three/examples/jsm/nodes/accessors/UVNode.js
var UVNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec2");
    this.isUVNode = true;
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "uv" + (index > 0 ? index : "");
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
var UVNode_default = UVNode;
var uv = (...params) => nodeObject(new UVNode(...params));
addNodeClass("UVNode", UVNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureSizeNode.js
var TextureSizeNode = class extends Node_default {
  constructor(textureNode, levelNode = null) {
    super("uvec2");
    this.isTextureSizeNode = true;
    this.textureNode = textureNode;
    this.levelNode = levelNode;
  }
  generate(builder, output2) {
    const textureProperty = this.textureNode.build(builder, "property");
    const levelNode = this.levelNode.build(builder, "int");
    return builder.format(`${builder.getMethod("textureDimensions")}( ${textureProperty}, ${levelNode} )`, this.getNodeType(builder), output2);
  }
};
var textureSize = nodeProxy(TextureSizeNode);
addNodeElement("textureSize", textureSize);
addNodeClass("TextureSizeNode", TextureSizeNode);

// node_modules/three/examples/jsm/nodes/math/OperatorNode.js
var OperatorNode = class _OperatorNode extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i = 0; i < params.length; i++) {
        finalBNode = new _OperatorNode(op, finalBNode, params[i]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getNodeType(builder, output2) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode.getNodeType(builder);
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "%") {
      return typeA;
    } else if (op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return builder.getIntegerType(typeA);
    } else if (op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = output2 ? builder.getTypeLength(output2) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output2) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output2);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode.getNodeType(builder);
      if (op === "<" || op === ">" || op === "<=" || op === ">=" || op === "==") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = bNode.build(builder, typeB);
    const outputLength = builder.getTypeLength(output2);
    if (output2 !== "void") {
      if (op === "<" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThan")}( ${a}, ${b} )`, type, output2);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a}, ${b} )`, type, output2);
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a}, ${b} )`, type, output2);
      } else if (op === ">=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThanEqual")}( ${a}, ${b} )`, type, output2);
      } else {
        return builder.format(`( ${a} ${this.op} ${b} )`, type, output2);
      }
    } else if (typeA !== "void") {
      return builder.format(`${a} ${this.op} ${b}`, type, output2);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;
var add = nodeProxy(OperatorNode, "+");
var sub = nodeProxy(OperatorNode, "-");
var mul = nodeProxy(OperatorNode, "*");
var div = nodeProxy(OperatorNode, "/");
var remainder = nodeProxy(OperatorNode, "%");
var equal = nodeProxy(OperatorNode, "==");
var notEqual = nodeProxy(OperatorNode, "!=");
var lessThan = nodeProxy(OperatorNode, "<");
var greaterThan = nodeProxy(OperatorNode, ">");
var lessThanEqual = nodeProxy(OperatorNode, "<=");
var greaterThanEqual = nodeProxy(OperatorNode, ">=");
var and = nodeProxy(OperatorNode, "&&");
var or = nodeProxy(OperatorNode, "||");
var xor = nodeProxy(OperatorNode, "^^");
var bitAnd = nodeProxy(OperatorNode, "&");
var bitOr = nodeProxy(OperatorNode, "|");
var bitXor = nodeProxy(OperatorNode, "^");
var shiftLeft = nodeProxy(OperatorNode, "<<");
var shiftRight = nodeProxy(OperatorNode, ">>");
addNodeElement("add", add);
addNodeElement("sub", sub);
addNodeElement("mul", mul);
addNodeElement("div", div);
addNodeElement("remainder", remainder);
addNodeElement("equal", equal);
addNodeElement("notEqual", notEqual);
addNodeElement("lessThan", lessThan);
addNodeElement("greaterThan", greaterThan);
addNodeElement("lessThanEqual", lessThanEqual);
addNodeElement("greaterThanEqual", greaterThanEqual);
addNodeElement("and", and);
addNodeElement("or", or);
addNodeElement("xor", xor);
addNodeElement("bitAnd", bitAnd);
addNodeElement("bitOr", bitOr);
addNodeElement("bitXor", bitXor);
addNodeElement("shiftLeft", shiftLeft);
addNodeElement("shiftRight", shiftRight);
addNodeClass("OperatorNode", OperatorNode);

// node_modules/three/examples/jsm/nodes/math/MathNode.js
var MathNode = class _MathNode extends TempNode_default {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === _MathNode.LENGTH || method === _MathNode.DISTANCE || method === _MathNode.DOT) {
      return "float";
    } else if (method === _MathNode.CROSS) {
      return "vec3";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output2) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (method === _MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = vec4(vec3(tB), 0);
      } else {
        tA = vec4(vec3(tA), 0);
      }
      const mulNode = mul(tA, tB).xyz;
      return normalize(mulNode).build(builder, output2);
    } else if (method === _MathNode.NEGATE) {
      return builder.format("( - " + a.build(builder, inputType) + " )", type, output2);
    } else if (method === _MathNode.ONE_MINUS) {
      return sub(1, a).build(builder, output2);
    } else if (method === _MathNode.RECIPROCAL) {
      return div(1, a).build(builder, output2);
    } else if (method === _MathNode.DIFFERENCE) {
      return abs(sub(a, b)).build(builder, output2);
    } else {
      const params = [];
      if (method === _MathNode.CROSS) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (method === _MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (isWebGL && (method === _MathNode.MIN || method === _MathNode.MAX) || method === _MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === _MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === _MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        params.push(a.build(builder, inputType));
        if (b !== null)
          params.push(b.build(builder, inputType));
        if (c !== null)
          params.push(c.build(builder, inputType));
      }
      return builder.format(`${builder.getMethod(method)}( ${params.join(", ")} )`, type, output2);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.ONE_MINUS = "oneMinus";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.TRUNC = "trunc";
MathNode.FWIDTH = "fwidth";
MathNode.ATAN2 = "atan2";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.MOD = "mod";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DIFFERENCE = "difference";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
var MathNode_default = MathNode;
var EPSILON = float(1e-6);
var INFINITY = float(1e6);
var radians = nodeProxy(MathNode, MathNode.RADIANS);
var degrees = nodeProxy(MathNode, MathNode.DEGREES);
var exp = nodeProxy(MathNode, MathNode.EXP);
var exp2 = nodeProxy(MathNode, MathNode.EXP2);
var log = nodeProxy(MathNode, MathNode.LOG);
var log2 = nodeProxy(MathNode, MathNode.LOG2);
var sqrt = nodeProxy(MathNode, MathNode.SQRT);
var inverseSqrt = nodeProxy(MathNode, MathNode.INVERSE_SQRT);
var floor = nodeProxy(MathNode, MathNode.FLOOR);
var ceil = nodeProxy(MathNode, MathNode.CEIL);
var normalize = nodeProxy(MathNode, MathNode.NORMALIZE);
var fract = nodeProxy(MathNode, MathNode.FRACT);
var sin = nodeProxy(MathNode, MathNode.SIN);
var cos = nodeProxy(MathNode, MathNode.COS);
var tan = nodeProxy(MathNode, MathNode.TAN);
var asin = nodeProxy(MathNode, MathNode.ASIN);
var acos = nodeProxy(MathNode, MathNode.ACOS);
var atan = nodeProxy(MathNode, MathNode.ATAN);
var abs = nodeProxy(MathNode, MathNode.ABS);
var sign = nodeProxy(MathNode, MathNode.SIGN);
var length = nodeProxy(MathNode, MathNode.LENGTH);
var negate = nodeProxy(MathNode, MathNode.NEGATE);
var oneMinus = nodeProxy(MathNode, MathNode.ONE_MINUS);
var dFdx = nodeProxy(MathNode, MathNode.DFDX);
var dFdy = nodeProxy(MathNode, MathNode.DFDY);
var round = nodeProxy(MathNode, MathNode.ROUND);
var reciprocal = nodeProxy(MathNode, MathNode.RECIPROCAL);
var trunc = nodeProxy(MathNode, MathNode.TRUNC);
var fwidth = nodeProxy(MathNode, MathNode.FWIDTH);
var atan2 = nodeProxy(MathNode, MathNode.ATAN2);
var min = nodeProxy(MathNode, MathNode.MIN);
var max = nodeProxy(MathNode, MathNode.MAX);
var mod = nodeProxy(MathNode, MathNode.MOD);
var step = nodeProxy(MathNode, MathNode.STEP);
var reflect = nodeProxy(MathNode, MathNode.REFLECT);
var distance = nodeProxy(MathNode, MathNode.DISTANCE);
var difference = nodeProxy(MathNode, MathNode.DIFFERENCE);
var dot = nodeProxy(MathNode, MathNode.DOT);
var cross = nodeProxy(MathNode, MathNode.CROSS);
var pow = nodeProxy(MathNode, MathNode.POW);
var pow2 = nodeProxy(MathNode, MathNode.POW, 2);
var pow3 = nodeProxy(MathNode, MathNode.POW, 3);
var pow4 = nodeProxy(MathNode, MathNode.POW, 4);
var transformDirection = nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);
var mix = nodeProxy(MathNode, MathNode.MIX);
var clamp = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
var saturate = (value) => clamp(value);
var refract = nodeProxy(MathNode, MathNode.REFRACT);
var smoothstep = nodeProxy(MathNode, MathNode.SMOOTHSTEP);
var faceForward = nodeProxy(MathNode, MathNode.FACEFORWARD);
var mixElement = (t, e1, e2) => mix(e1, e2, t);
var smoothstepElement = (x, low, high) => smoothstep(low, high, x);
addNodeElement("radians", radians);
addNodeElement("degrees", degrees);
addNodeElement("exp", exp);
addNodeElement("exp2", exp2);
addNodeElement("log", log);
addNodeElement("log2", log2);
addNodeElement("sqrt", sqrt);
addNodeElement("inverseSqrt", inverseSqrt);
addNodeElement("floor", floor);
addNodeElement("ceil", ceil);
addNodeElement("normalize", normalize);
addNodeElement("fract", fract);
addNodeElement("sin", sin);
addNodeElement("cos", cos);
addNodeElement("tan", tan);
addNodeElement("asin", asin);
addNodeElement("acos", acos);
addNodeElement("atan", atan);
addNodeElement("abs", abs);
addNodeElement("sign", sign);
addNodeElement("length", length);
addNodeElement("negate", negate);
addNodeElement("oneMinus", oneMinus);
addNodeElement("dFdx", dFdx);
addNodeElement("dFdy", dFdy);
addNodeElement("round", round);
addNodeElement("reciprocal", reciprocal);
addNodeElement("trunc", trunc);
addNodeElement("fwidth", fwidth);
addNodeElement("atan2", atan2);
addNodeElement("min", min);
addNodeElement("max", max);
addNodeElement("mod", mod);
addNodeElement("step", step);
addNodeElement("reflect", reflect);
addNodeElement("distance", distance);
addNodeElement("dot", dot);
addNodeElement("cross", cross);
addNodeElement("pow", pow);
addNodeElement("pow2", pow2);
addNodeElement("pow3", pow3);
addNodeElement("pow4", pow4);
addNodeElement("transformDirection", transformDirection);
addNodeElement("mix", mixElement);
addNodeElement("clamp", clamp);
addNodeElement("refract", refract);
addNodeElement("smoothstep", smoothstepElement);
addNodeElement("faceForward", faceForward);
addNodeElement("difference", difference);
addNodeElement("saturate", saturate);
addNodeClass("MathNode", MathNode);

// node_modules/three/examples/jsm/nodes/display/ColorSpaceNode.js
var sRGBToLinearShader = tslFn((inputs) => {
  const { value } = inputs;
  const { rgb } = value;
  const a = rgb.mul(0.9478672986).add(0.0521327014).pow(2.4);
  const b = rgb.mul(0.0773993808);
  const factor = rgb.lessThanEqual(0.04045);
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var LinearTosRGBShader = tslFn((inputs) => {
  const { value } = inputs;
  const { rgb } = value;
  const a = rgb.pow(0.41666).mul(1.055).sub(0.055);
  const b = rgb.mul(12.92);
  const factor = rgb.lessThanEqual(31308e-7);
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var getColorSpaceMethod = (colorSpace) => {
  let method = null;
  if (colorSpace === LinearSRGBColorSpace) {
    method = "Linear";
  } else if (colorSpace === SRGBColorSpace) {
    method = "sRGB";
  }
  return method;
};
var getMethod = (source, target) => {
  return getColorSpaceMethod(source) + "To" + getColorSpaceMethod(target);
};
var ColorSpaceNode = class _ColorSpaceNode extends TempNode_default {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  setup() {
    const { method, node } = this;
    if (method === _ColorSpaceNode.LINEAR_TO_LINEAR)
      return node;
    return Methods[method]({ value: node });
  }
};
ColorSpaceNode.LINEAR_TO_LINEAR = "LinearToLinear";
ColorSpaceNode.LINEAR_TO_sRGB = "LinearTosRGB";
ColorSpaceNode.sRGB_TO_LINEAR = "sRGBToLinear";
var Methods = {
  [ColorSpaceNode.LINEAR_TO_sRGB]: LinearTosRGBShader,
  [ColorSpaceNode.sRGB_TO_LINEAR]: sRGBToLinearShader
};
var ColorSpaceNode_default = ColorSpaceNode;
var linearToColorSpace = (node, colorSpace) => nodeObject(new ColorSpaceNode(getMethod(LinearSRGBColorSpace, colorSpace), nodeObject(node)));
var colorSpaceToLinear = (node, colorSpace) => nodeObject(new ColorSpaceNode(getMethod(colorSpace, LinearSRGBColorSpace), nodeObject(node)));
var linearTosRGB = nodeProxy(ColorSpaceNode, ColorSpaceNode.LINEAR_TO_sRGB);
var sRGBToLinear = nodeProxy(ColorSpaceNode, ColorSpaceNode.sRGB_TO_LINEAR);
addNodeElement("linearTosRGB", linearTosRGB);
addNodeElement("sRGBToLinear", sRGBToLinear);
addNodeElement("linearToColorSpace", linearToColorSpace);
addNodeElement("colorSpaceToLinear", colorSpaceToLinear);
addNodeClass("ColorSpaceNode", ColorSpaceNode);

// node_modules/three/examples/jsm/nodes/code/ExpressionNode.js
var ExpressionNode = class extends Node_default {
  constructor(snippet = "", nodeType = "void") {
    super(nodeType);
    this.snippet = snippet;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const snippet = this.snippet;
    if (type === "void") {
      builder.addLineFlowCode(snippet);
    } else {
      return builder.format(`( ${snippet} )`, type, output2);
    }
  }
};
var ExpressionNode_default = ExpressionNode;
var expression = nodeProxy(ExpressionNode);
addNodeClass("ExpressionNode", ExpressionNode);

// node_modules/three/examples/jsm/nodes/utils/MaxMipLevelNode.js
var MaxMipLevelNode = class extends UniformNode_default {
  constructor(textureNode) {
    super(0);
    this.textureNode = textureNode;
    this.updateType = NodeUpdateType.FRAME;
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const texture2 = this.texture;
    const images = texture2.images;
    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture2.image;
    if (image && image.width !== void 0) {
      const { width, height } = image;
      this.value = Math.log2(Math.max(width, height));
    }
  }
};
var MaxMipLevelNode_default = MaxMipLevelNode;
var maxMipLevel = nodeProxy(MaxMipLevelNode);
addNodeClass("MaxMipLevelNode", MaxMipLevelNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureNode.js
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value);
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this.compareNode = null;
    this.depthNode = null;
    this.sampler = true;
    this.updateMatrix = false;
    this.updateType = NodeUpdateType.NONE;
    this.setUpdateMatrix(uvNode === null);
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    if (this.value.isDepthTexture === true)
      return "float";
    return "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return uv(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(uvNode) {
    const texture2 = this.value;
    return uniform(texture2.matrix).mul(vec3(uvNode, 1)).xy;
  }
  setUpdateMatrix(value) {
    this.updateMatrix = value;
    this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;
    return this;
  }
  setup(builder) {
    const properties = builder.getNodeProperties(this);
    let uvNode = this.uvNode;
    if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {
      uvNode = builder.context.getUV(this);
    }
    if (!uvNode)
      uvNode = this.getDefaultUV();
    if (this.updateMatrix === true) {
      uvNode = this.getTransformedUV(uvNode);
    }
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    if (levelNode !== null && builder.context.getTextureLevelAlgorithm !== void 0) {
      levelNode = builder.context.getTextureLevelAlgorithm(this, levelNode);
    }
    properties.uvNode = uvNode;
    properties.levelNode = levelNode;
    properties.compareNode = this.compareNode;
    properties.depthNode = this.depthNode;
  }
  generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet) {
    const texture2 = this.value;
    let snippet;
    if (levelSnippet) {
      snippet = builder.generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet);
    } else if (compareSnippet) {
      snippet = builder.generateTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet, depthSnippet);
    } else if (this.sampler === false) {
      snippet = builder.generateTextureLoad(texture2, textureProperty, uvSnippet, depthSnippet);
    } else {
      snippet = builder.generateTexture(texture2, textureProperty, uvSnippet, depthSnippet);
    }
    return snippet;
  }
  generateUV(builder, uvNode) {
    const texture2 = this.value;
    if (builder.isFlipY() && (texture2.isFramebufferTexture === true || texture2.isDepthTexture === true) || builder.isFlipY() === false && texture2.isRenderTargetTexture === true) {
      uvNode = uvNode.setY(uvNode.y.fract().oneMinus());
    }
    return uvNode.build(builder, this.sampler === true ? "vec2" : "ivec2");
  }
  generate(builder, output2) {
    const properties = builder.getNodeProperties(this);
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "property");
    if (output2 === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output2)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const { uvNode, levelNode, compareNode, depthNode } = properties;
        const uvSnippet = this.generateUV(builder, uvNode);
        const levelSnippet = levelNode ? levelNode.build(builder, "float") : null;
        const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
        const compareSnippet = compareNode ? compareNode.build(builder, "float") : null;
        const nodeVar = builder.getVarFromNode(this);
        propertyName = builder.getPropertyName(nodeVar);
        const snippet2 = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet);
        builder.addLineFlowCode(`${propertyName} = ${snippet2}`);
        if (builder.context.tempWrite !== false) {
          nodeData.snippet = snippet2;
          nodeData.propertyName = propertyName;
        }
      }
      let snippet = propertyName;
      const nodeType = this.getNodeType(builder);
      if (builder.needsColorSpaceToLinear(texture2)) {
        snippet = colorSpaceToLinear(expression(snippet, nodeType), texture2.colorSpace).setup(builder).build(builder, nodeType);
      }
      return builder.format(snippet, nodeType, output2);
    }
  }
  setSampler(value) {
    this.sampler = value;
    return this;
  }
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  uv(uvNode) {
    const textureNode = this.clone();
    textureNode.uvNode = uvNode;
    return nodeObject(textureNode);
  }
  blur(levelNode) {
    const textureNode = this.clone();
    textureNode.levelNode = levelNode.mul(maxMipLevel(textureNode));
    return nodeObject(textureNode);
  }
  level(levelNode) {
    const textureNode = this.clone();
    textureNode.levelNode = levelNode;
    return textureNode;
  }
  size(levelNode) {
    return textureSize(this, levelNode);
  }
  compare(compareNode) {
    const textureNode = this.clone();
    textureNode.compareNode = nodeObject(compareNode);
    return nodeObject(textureNode);
  }
  depth(depthNode) {
    const textureNode = this.clone();
    textureNode.depthNode = nodeObject(depthNode);
    return nodeObject(textureNode);
  }
  // --
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
  update() {
    const texture2 = this.value;
    if (texture2.matrixAutoUpdate === true) {
      texture2.updateMatrix();
    }
  }
  clone() {
    const newNode = new this.constructor(this.value, this.uvNode, this.levelNode);
    newNode.sampler = this.sampler;
    return newNode;
  }
};
var TextureNode_default = TextureNode;
var texture = nodeProxy(TextureNode);
var textureLoad = (...params) => texture(...params).setSampler(false);
var sampler = (aTexture) => (aTexture.isNode === true ? aTexture : texture(aTexture)).convert("sampler");
addNodeElement("texture", texture);
addNodeClass("TextureNode", TextureNode);

// node_modules/three/examples/jsm/nodes/accessors/ReferenceNode.js
var ReferenceNode = class extends Node_default {
  constructor(property2, uniformType, object = null) {
    super();
    this.property = property2;
    this.index = null;
    this.uniformType = uniformType;
    this.object = object;
    this.reference = null;
    this.node = null;
    this.updateType = NodeUpdateType.OBJECT;
    this.setNodeType(uniformType);
  }
  updateReference(frame) {
    this.reference = this.object !== null ? this.object : frame.object;
    return this.reference;
  }
  setIndex(index) {
    this.index = index;
    return this;
  }
  getIndex() {
    return this.index;
  }
  setNodeType(uniformType) {
    let node = null;
    if (uniformType === "texture") {
      node = texture(null);
    } else {
      node = uniform(uniformType);
    }
    this.node = node;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  update() {
    let value = this.reference[this.property];
    if (this.index !== null) {
      value = value[this.index];
    }
    this.node.value = value;
  }
  setup() {
    return this.node;
  }
};
var ReferenceNode_default = ReferenceNode;
var reference = (name, type, object) => nodeObject(new ReferenceNode(name, type, object));
var referenceIndex = (name, index, type, object) => nodeObject(new ReferenceNode(name, type, object).setIndex(index));
addNodeClass("ReferenceNode", ReferenceNode);

// node_modules/three/examples/jsm/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property2, inputType, material = null) {
    super(property2, inputType, material);
    this.material = material;
  }
  /*setNodeType( node ) {
  
  		super.setNodeType( node );
  
  		this.node.groupNode = renderGroup;
  
  	}*/
  updateReference(frame) {
    this.reference = this.material !== null ? this.material : frame.material;
    return this.reference;
  }
  setup(builder) {
    const material = this.material !== null ? this.material : builder.material;
    this.node.value = material[this.property];
    return super.setup(builder);
  }
};
var MaterialReferenceNode_default = MaterialReferenceNode;
var materialReference = (name, type, material) => nodeObject(new MaterialReferenceNode(name, type, material));
addNodeClass("MaterialReferenceNode", MaterialReferenceNode);

// node_modules/three/examples/jsm/nodes/accessors/Object3DNode.js
var Object3DNode = class _Object3DNode extends Node_default {
  constructor(scope = _Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.OBJECT;
    this._uniformNode = new UniformNode_default(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope === _Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === _Object3DNode.POSITION) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === _Object3DNode.SCALE) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixScale(object.matrixWorld);
    } else if (scope === _Object3DNode.DIRECTION) {
      uniformNode.value = uniformNode.value || new Vector3();
      object.getWorldDirection(uniformNode.value);
    } else if (scope === _Object3DNode.VIEW_POSITION) {
      const camera = frame.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      this._uniformNode.nodeType = "vec3";
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
Object3DNode.VIEW_MATRIX = "viewMatrix";
Object3DNode.NORMAL_MATRIX = "normalMatrix";
Object3DNode.WORLD_MATRIX = "worldMatrix";
Object3DNode.POSITION = "position";
Object3DNode.SCALE = "scale";
Object3DNode.VIEW_POSITION = "viewPosition";
Object3DNode.DIRECTION = "direction";
var Object3DNode_default = Object3DNode;
var objectDirection = nodeProxy(Object3DNode, Object3DNode.DIRECTION);
var objectViewMatrix = nodeProxy(Object3DNode, Object3DNode.VIEW_MATRIX);
var objectNormalMatrix = nodeProxy(Object3DNode, Object3DNode.NORMAL_MATRIX);
var objectWorldMatrix = nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX);
var objectPosition = nodeProxy(Object3DNode, Object3DNode.POSITION);
var objectScale = nodeProxy(Object3DNode, Object3DNode.SCALE);
var objectViewPosition = nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION);
addNodeClass("Object3DNode", Object3DNode);

// node_modules/three/examples/jsm/nodes/accessors/CameraNode.js
var CameraNode = class _CameraNode extends Object3DNode_default {
  constructor(scope = _CameraNode.POSITION) {
    super(scope);
    this.updateType = NodeUpdateType.RENDER;
  }
  getNodeType(builder) {
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      return "mat4";
    } else if (scope === _CameraNode.NEAR || scope === _CameraNode.FAR || scope === _CameraNode.LOG_DEPTH) {
      return "float";
    }
    return super.getNodeType(builder);
  }
  update(frame) {
    const camera = frame.camera;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _CameraNode.VIEW_MATRIX) {
      uniformNode.value = camera.matrixWorldInverse;
    } else if (scope === _CameraNode.PROJECTION_MATRIX) {
      uniformNode.value = camera.projectionMatrix;
    } else if (scope === _CameraNode.NEAR) {
      uniformNode.value = camera.near;
    } else if (scope === _CameraNode.FAR) {
      uniformNode.value = camera.far;
    } else if (scope === _CameraNode.LOG_DEPTH) {
      uniformNode.value = 2 / (Math.log(camera.far + 1) / Math.LN2);
    } else {
      this.object3d = camera;
      super.update(frame);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === _CameraNode.NEAR || scope === _CameraNode.FAR || scope === _CameraNode.LOG_DEPTH) {
      this._uniformNode.nodeType = "float";
    }
    return super.generate(builder);
  }
};
CameraNode.PROJECTION_MATRIX = "projectionMatrix";
CameraNode.NEAR = "near";
CameraNode.FAR = "far";
CameraNode.LOG_DEPTH = "logDepth";
var CameraNode_default = CameraNode;
var cameraProjectionMatrix = label(nodeImmutable(CameraNode, CameraNode.PROJECTION_MATRIX), "projectionMatrix");
var cameraNear = nodeImmutable(CameraNode, CameraNode.NEAR);
var cameraFar = nodeImmutable(CameraNode, CameraNode.FAR);
var cameraLogDepth = nodeImmutable(CameraNode, CameraNode.LOG_DEPTH);
var cameraViewMatrix = nodeImmutable(CameraNode, CameraNode.VIEW_MATRIX);
var cameraNormalMatrix = nodeImmutable(CameraNode, CameraNode.NORMAL_MATRIX);
var cameraWorldMatrix = nodeImmutable(CameraNode, CameraNode.WORLD_MATRIX);
var cameraPosition = nodeImmutable(CameraNode, CameraNode.POSITION);
addNodeClass("CameraNode", CameraNode);

// node_modules/three/examples/jsm/nodes/accessors/ModelNode.js
var ModelNode = class _ModelNode extends Object3DNode_default {
  constructor(scope = _ModelNode.VIEW_MATRIX) {
    super(scope);
  }
  update(frame) {
    this.object3d = frame.object;
    super.update(frame);
  }
};
var ModelNode_default = ModelNode;
var modelDirection = nodeImmutable(ModelNode, ModelNode.DIRECTION);
var modelViewMatrix = nodeImmutable(ModelNode, ModelNode.VIEW_MATRIX).label("modelViewMatrix").temp("ModelViewMatrix");
var modelNormalMatrix = nodeImmutable(ModelNode, ModelNode.NORMAL_MATRIX);
var modelWorldMatrix = nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);
var modelPosition = nodeImmutable(ModelNode, ModelNode.POSITION);
var modelScale = nodeImmutable(ModelNode, ModelNode.SCALE);
var modelViewPosition = nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);
addNodeClass("ModelNode", ModelNode);

// node_modules/three/examples/jsm/nodes/accessors/NormalNode.js
var NormalNode = class _NormalNode extends Node_default {
  constructor(scope = _NormalNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  isGlobal() {
    return true;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _NormalNode.GEOMETRY) {
      outputNode = attribute("normal", "vec3");
    } else if (scope === _NormalNode.LOCAL) {
      outputNode = varying(normalGeometry);
    } else if (scope === _NormalNode.VIEW) {
      const vertexNode = modelNormalMatrix.mul(normalLocal);
      outputNode = normalize(varying(vertexNode));
    } else if (scope === _NormalNode.WORLD) {
      const vertexNode = normalView.transformDirection(cameraViewMatrix);
      outputNode = normalize(varying(vertexNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
NormalNode.GEOMETRY = "geometry";
NormalNode.LOCAL = "local";
NormalNode.VIEW = "view";
NormalNode.WORLD = "world";
var NormalNode_default = NormalNode;
var normalGeometry = nodeImmutable(NormalNode, NormalNode.GEOMETRY);
var normalLocal = nodeImmutable(NormalNode, NormalNode.LOCAL).temp("Normal");
var normalView = nodeImmutable(NormalNode, NormalNode.VIEW);
var normalWorld = nodeImmutable(NormalNode, NormalNode.WORLD);
var transformedNormalView = property("vec3", "TransformedNormalView");
var transformedNormalWorld = transformedNormalView.transformDirection(cameraViewMatrix).normalize();
var transformedClearcoatNormalView = property("vec3", "TransformedClearcoatNormalView");
addNodeClass("NormalNode", NormalNode);

// node_modules/three/examples/jsm/nodes/accessors/MaterialNode.js
var _propertyCache = /* @__PURE__ */ new Map();
var MaterialNode = class _MaterialNode extends Node_default {
  constructor(scope) {
    super();
    this.scope = scope;
  }
  getCache(property2, type) {
    let node = _propertyCache.get(property2);
    if (node === void 0) {
      node = materialReference(property2, type);
      _propertyCache.set(property2, node);
    }
    return node;
  }
  getFloat(property2) {
    return this.getCache(property2, "float");
  }
  getColor(property2) {
    return this.getCache(property2, "color");
  }
  getTexture(property2) {
    return this.getCache(property2 === "map" ? "map" : property2 + "Map", "texture");
  }
  setup(builder) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === _MaterialNode.COLOR) {
      const colorNode = this.getColor(scope);
      if (material.map && material.map.isTexture === true) {
        node = colorNode.mul(this.getTexture("map"));
      } else {
        node = colorNode;
      }
    } else if (scope === _MaterialNode.OPACITY) {
      const opacityNode = this.getFloat(scope);
      if (material.alphaMap && material.alphaMap.isTexture === true) {
        node = opacityNode.mul(this.getTexture("alpha"));
      } else {
        node = opacityNode;
      }
    } else if (scope === _MaterialNode.SPECULAR_STRENGTH) {
      if (material.specularMap && material.specularMap.isTexture === true) {
        node = this.getTexture(scope).r;
      } else {
        node = float(1);
      }
    } else if (scope === _MaterialNode.ROUGHNESS) {
      const roughnessNode = this.getFloat(scope);
      if (material.roughnessMap && material.roughnessMap.isTexture === true) {
        node = roughnessNode.mul(this.getTexture(scope).g);
      } else {
        node = roughnessNode;
      }
    } else if (scope === _MaterialNode.METALNESS) {
      const metalnessNode = this.getFloat(scope);
      if (material.metalnessMap && material.metalnessMap.isTexture === true) {
        node = metalnessNode.mul(this.getTexture(scope).b);
      } else {
        node = metalnessNode;
      }
    } else if (scope === _MaterialNode.EMISSIVE) {
      const emissiveNode = this.getColor(scope);
      if (material.emissiveMap && material.emissiveMap.isTexture === true) {
        node = emissiveNode.mul(this.getTexture(scope));
      } else {
        node = emissiveNode;
      }
    } else if (scope === _MaterialNode.NORMAL) {
      if (material.normalMap) {
        node = this.getTexture("normal").normalMap(this.getCache("normalScale", "vec2"));
      } else if (material.bumpMap) {
        node = this.getTexture("bump").r.bumpMap(this.getFloat("bumpScale"));
      } else {
        node = normalView;
      }
    } else if (scope === _MaterialNode.CLEARCOAT) {
      const clearcoatNode = this.getFloat(scope);
      if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {
        node = clearcoatNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_ROUGHNESS) {
      const clearcoatRoughnessNode = this.getFloat(scope);
      if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {
        node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatRoughnessNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_NORMAL) {
      if (material.clearcoatNormalMap) {
        node = this.getTexture(scope).normalMap(this.getCache(scope + "Scale", "vec2"));
      } else {
        node = normalView;
      }
    } else if (scope === _MaterialNode.SHEEN) {
      const sheenNode = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {
        node = sheenNode.mul(this.getTexture("sheenColor").rgb);
      } else {
        node = sheenNode;
      }
    } else if (scope === _MaterialNode.SHEEN_ROUGHNESS) {
      const sheenRoughnessNode = this.getFloat(scope);
      if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {
        node = sheenRoughnessNode.mul(this.getTexture(scope).a);
      } else {
        node = sheenRoughnessNode;
      }
      node = node.clamp(0.07, 1);
    } else if (scope === _MaterialNode.IRIDESCENCE_THICKNESS) {
      const iridescenceThicknessMaximum = reference(1, "float", material.iridescenceThicknessRange);
      if (material.iridescenceThicknessMap) {
        const iridescenceThicknessMinimum = reference(0, "float", material.iridescenceThicknessRange);
        node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);
      } else {
        node = iridescenceThicknessMaximum;
      }
    } else {
      const outputType = this.getNodeType(builder);
      node = this.getCache(scope, outputType);
    }
    return node;
  }
};
MaterialNode.ALPHA_TEST = "alphaTest";
MaterialNode.COLOR = "color";
MaterialNode.OPACITY = "opacity";
MaterialNode.SHININESS = "shininess";
MaterialNode.SPECULAR_COLOR = "specular";
MaterialNode.SPECULAR_STRENGTH = "specularStrength";
MaterialNode.REFLECTIVITY = "reflectivity";
MaterialNode.ROUGHNESS = "roughness";
MaterialNode.METALNESS = "metalness";
MaterialNode.NORMAL = "normal";
MaterialNode.CLEARCOAT = "clearcoat";
MaterialNode.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
MaterialNode.CLEARCOAT_NORMAL = "clearcoatNormal";
MaterialNode.EMISSIVE = "emissive";
MaterialNode.ROTATION = "rotation";
MaterialNode.SHEEN = "sheen";
MaterialNode.SHEEN_ROUGHNESS = "sheenRoughness";
MaterialNode.IRIDESCENCE = "iridescence";
MaterialNode.IRIDESCENCE_IOR = "iridescenceIOR";
MaterialNode.IRIDESCENCE_THICKNESS = "iridescenceThickness";
MaterialNode.LINE_SCALE = "scale";
MaterialNode.LINE_DASH_SIZE = "dashSize";
MaterialNode.LINE_GAP_SIZE = "gapSize";
MaterialNode.LINE_WIDTH = "linewidth";
MaterialNode.LINE_DASH_OFFSET = "dashOffset";
MaterialNode.POINT_WIDTH = "pointWidth";
var MaterialNode_default = MaterialNode;
var materialAlphaTest = nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode, MaterialNode.COLOR);
var materialShininess = nodeImmutable(MaterialNode, MaterialNode.SHININESS);
var materialEmissive = nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);
var materialOpacity = nodeImmutable(MaterialNode, MaterialNode.OPACITY);
var materialSpecularColor = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);
var materialSpecularStrength = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);
var materialReflectivity = nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);
var materialRoughness = nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode, MaterialNode.METALNESS);
var materialNormal = nodeImmutable(MaterialNode, MaterialNode.NORMAL);
var materialClearcoat = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);
var materialClearcoatRoughness = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);
var materialClearcoatNormal = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_NORMAL);
var materialRotation = nodeImmutable(MaterialNode, MaterialNode.ROTATION);
var materialSheen = nodeImmutable(MaterialNode, MaterialNode.SHEEN);
var materialSheenRoughness = nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);
var materialIridescence = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);
var materialIridescenceIOR = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);
var materialIridescenceThickness = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);
var materialLineScale = nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);
var materialLineDashSize = nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_SIZE);
var materialLineGapSize = nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);
var materialLineWidth = nodeImmutable(MaterialNode, MaterialNode.LINE_WIDTH);
var materialLineDashOffset = nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);
var materialPointWidth = nodeImmutable(MaterialNode, MaterialNode.POINT_WIDTH);
addNodeClass("MaterialNode", MaterialNode);

// node_modules/three/examples/jsm/nodes/accessors/PositionNode.js
var PositionNode = class _PositionNode extends Node_default {
  constructor(scope = _PositionNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  isGlobal() {
    return true;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _PositionNode.GEOMETRY) {
      outputNode = attribute("position", "vec3");
    } else if (scope === _PositionNode.LOCAL) {
      outputNode = varying(positionGeometry);
    } else if (scope === _PositionNode.WORLD) {
      const vertexPositionNode = modelWorldMatrix.mul(positionLocal);
      outputNode = varying(vertexPositionNode);
    } else if (scope === _PositionNode.VIEW) {
      const vertexPositionNode = modelViewMatrix.mul(positionLocal);
      outputNode = varying(vertexPositionNode);
    } else if (scope === _PositionNode.VIEW_DIRECTION) {
      const vertexPositionNode = positionView.negate();
      outputNode = normalize(varying(vertexPositionNode));
    } else if (scope === _PositionNode.WORLD_DIRECTION) {
      const vertexPositionNode = positionLocal.transformDirection(modelWorldMatrix);
      outputNode = normalize(varying(vertexPositionNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
PositionNode.GEOMETRY = "geometry";
PositionNode.LOCAL = "local";
PositionNode.WORLD = "world";
PositionNode.WORLD_DIRECTION = "worldDirection";
PositionNode.VIEW = "view";
PositionNode.VIEW_DIRECTION = "viewDirection";
var PositionNode_default = PositionNode;
var positionGeometry = nodeImmutable(PositionNode, PositionNode.GEOMETRY);
var positionLocal = nodeImmutable(PositionNode, PositionNode.LOCAL).temp("Position");
var positionWorld = nodeImmutable(PositionNode, PositionNode.WORLD);
var positionWorldDirection = nodeImmutable(PositionNode, PositionNode.WORLD_DIRECTION);
var positionView = nodeImmutable(PositionNode, PositionNode.VIEW);
var positionViewDirection = nodeImmutable(PositionNode, PositionNode.VIEW_DIRECTION);
addNodeClass("PositionNode", PositionNode);

// node_modules/three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js
var ModelViewProjectionNode = class extends TempNode_default {
  constructor(positionNode = null) {
    super("vec4");
    this.positionNode = positionNode;
  }
  setup(builder) {
    if (builder.shaderStage === "fragment") {
      return varying(builder.context.mvp);
    }
    const position = this.positionNode || positionLocal;
    return cameraProjectionMatrix.mul(modelViewMatrix).mul(position);
  }
};
var ModelViewProjectionNode_default = ModelViewProjectionNode;
var modelViewProjection = nodeProxy(ModelViewProjectionNode);
addNodeClass("ModelViewProjectionNode", ModelViewProjectionNode);

// node_modules/three/examples/jsm/nodes/accessors/BufferAttributeNode.js
var BufferAttributeNode = class extends InputNode_default {
  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferStride = bufferStride;
    this.bufferOffset = bufferOffset;
    this.usage = StaticDrawUsage;
    this.instanced = false;
    this.attribute = null;
    if (value && value.isBufferAttribute === true) {
      this.attribute = value;
      this.usage = value.usage;
      this.instanced = value.isInstancedBufferAttribute;
    }
  }
  getNodeType(builder) {
    if (this.bufferType === null) {
      this.bufferType = builder.getTypeFromAttribute(this.attribute);
    }
    return this.bufferType;
  }
  setup(builder) {
    if (this.attribute !== null)
      return;
    const type = this.getNodeType(builder);
    const array = this.value;
    const itemSize = builder.getTypeLength(type);
    const stride = this.bufferStride || itemSize;
    const offset = this.bufferOffset;
    const buffer2 = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);
    const bufferAttribute2 = new InterleavedBufferAttribute(buffer2, itemSize, offset);
    buffer2.setUsage(this.usage);
    this.attribute = bufferAttribute2;
    this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const nodeUniform = builder.getBufferAttributeFromNode(this, nodeType);
    const propertyName = builder.getPropertyName(nodeUniform);
    let output2 = null;
    if (builder.shaderStage === "vertex") {
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  setInstanced(value) {
    this.instanced = value;
    return this;
  }
};
var BufferAttributeNode_default = BufferAttributeNode;
var bufferAttribute = (array, type, stride, offset) => nodeObject(new BufferAttributeNode(array, type, stride, offset));
var dynamicBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);
var instancedBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setInstanced(true);
var instancedDynamicBufferAttribute = (array, type, stride, offset) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
addNodeElement("toAttribute", (bufferNode) => bufferAttribute(bufferNode.value));
addNodeClass("BufferAttributeNode", BufferAttributeNode);

// node_modules/three/examples/jsm/nodes/accessors/InstanceNode.js
var InstanceNode = class extends Node_default {
  constructor(instanceMesh) {
    super("void");
    this.instanceMesh = instanceMesh;
    this.instanceMatrixNode = null;
  }
  setup() {
    let instanceMatrixNode = this.instanceMatrixNode;
    if (instanceMatrixNode === null) {
      const instanceMesh = this.instanceMesh;
      const instanceAttribute = instanceMesh.instanceMatrix;
      const buffer2 = new InstancedInterleavedBuffer(instanceAttribute.array, 16, 1);
      const bufferFn = instanceAttribute.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
      const instanceBuffers = [
        // F.Signature -> bufferAttribute( array, type, stride, offset )
        bufferFn(buffer2, "vec4", 16, 0),
        bufferFn(buffer2, "vec4", 16, 4),
        bufferFn(buffer2, "vec4", 16, 8),
        bufferFn(buffer2, "vec4", 16, 12)
      ];
      instanceMatrixNode = mat4(...instanceBuffers);
      this.instanceMatrixNode = instanceMatrixNode;
    }
    const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;
    const m = mat3(instanceMatrixNode[0].xyz, instanceMatrixNode[1].xyz, instanceMatrixNode[2].xyz);
    const transformedNormal = normalLocal.div(vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));
    const instanceNormal = m.mul(transformedNormal).xyz;
    positionLocal.assign(instancePosition);
    normalLocal.assign(instanceNormal);
  }
};
var InstanceNode_default = InstanceNode;
var instance = nodeProxy(InstanceNode);
addNodeClass("InstanceNode", InstanceNode);

// node_modules/three/examples/jsm/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getInputType() {
    return "buffer";
  }
};
var BufferNode_default = BufferNode;
var buffer = (value, type, count) => nodeObject(new BufferNode(value, type, count));
addNodeClass("BufferNode", BufferNode);

// node_modules/three/examples/jsm/nodes/accessors/TangentNode.js
var TangentNode = class _TangentNode extends Node_default {
  constructor(scope = _TangentNode.LOCAL) {
    super();
    this.scope = scope;
  }
  getHash() {
    return `tangent-${this.scope}`;
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === _TangentNode.GEOMETRY) {
      return "vec4";
    }
    return "vec3";
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _TangentNode.GEOMETRY) {
      outputNode = attribute("tangent", "vec4");
    } else if (scope === _TangentNode.LOCAL) {
      outputNode = varying(tangentGeometry.xyz);
    } else if (scope === _TangentNode.VIEW) {
      const vertexNode = modelViewMatrix.mul(tangentLocal).xyz;
      outputNode = normalize(varying(vertexNode));
    } else if (scope === _TangentNode.WORLD) {
      const vertexNode = tangentView.transformDirection(cameraViewMatrix);
      outputNode = normalize(varying(vertexNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
TangentNode.GEOMETRY = "geometry";
TangentNode.LOCAL = "local";
TangentNode.VIEW = "view";
TangentNode.WORLD = "world";
var TangentNode_default = TangentNode;
var tangentGeometry = nodeImmutable(TangentNode, TangentNode.GEOMETRY);
var tangentLocal = nodeImmutable(TangentNode, TangentNode.LOCAL);
var tangentView = nodeImmutable(TangentNode, TangentNode.VIEW);
var tangentWorld = nodeImmutable(TangentNode, TangentNode.WORLD);
var transformedTangentView = temp(tangentView, "TransformedTangentView");
var transformedTangentWorld = normalize(transformedTangentView.transformDirection(cameraViewMatrix));
addNodeClass("TangentNode", TangentNode);

// node_modules/three/examples/jsm/nodes/accessors/SkinningNode.js
var SkinningNode = class extends Node_default {
  constructor(skinnedMesh) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.updateType = NodeUpdateType.OBJECT;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    this.bindMatrixNode = uniform(skinnedMesh.bindMatrix, "mat4");
    this.bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, "mat4");
    this.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
  }
  setup(builder) {
    const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode, boneMatricesNode } = this;
    const boneMatX = boneMatricesNode.element(skinIndexNode.x);
    const boneMatY = boneMatricesNode.element(skinIndexNode.y);
    const boneMatZ = boneMatricesNode.element(skinIndexNode.z);
    const boneMatW = boneMatricesNode.element(skinIndexNode.w);
    const skinVertex = bindMatrixNode.mul(positionLocal);
    const skinned = add(
      boneMatX.mul(skinWeightNode.x).mul(skinVertex),
      boneMatY.mul(skinWeightNode.y).mul(skinVertex),
      boneMatZ.mul(skinWeightNode.z).mul(skinVertex),
      boneMatW.mul(skinWeightNode.w).mul(skinVertex)
    );
    const skinPosition = bindMatrixInverseNode.mul(skinned).xyz;
    let skinMatrix = add(
      skinWeightNode.x.mul(boneMatX),
      skinWeightNode.y.mul(boneMatY),
      skinWeightNode.z.mul(boneMatZ),
      skinWeightNode.w.mul(boneMatW)
    );
    skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);
    const skinNormal = skinMatrix.transformDirection(normalLocal).xyz;
    positionLocal.assign(skinPosition);
    normalLocal.assign(skinNormal);
    if (builder.hasGeometryAttribute("tangent")) {
      tangentLocal.assign(skinNormal);
    }
  }
  generate(builder, output2) {
    if (output2 !== "void") {
      return positionLocal.build(builder, output2);
    }
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
};
var SkinningNode_default = SkinningNode;
var skinning = nodeProxy(SkinningNode);
addNodeClass("SkinningNode", SkinningNode);

// node_modules/three/examples/jsm/nodes/accessors/MorphNode.js
var morphTextures = /* @__PURE__ */ new WeakMap();
var morphVec4 = new Vector4();
var getMorph = tslFn(({ bufferMap, influence, stride, width, depth: depth2, offset }) => {
  const texelIndex = int(vertexIndex).mul(stride).add(offset);
  const y = texelIndex.div(width);
  const x = texelIndex.sub(y.mul(width));
  const bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth2);
  return bufferAttrib.mul(influence);
});
function getEntry(geometry) {
  const hasMorphPosition = geometry.morphAttributes.position !== void 0;
  const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
  const hasMorphColors = geometry.morphAttributes.color !== void 0;
  const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
  let entry = morphTextures.get(geometry);
  if (entry === void 0 || entry.count !== morphTargetsCount) {
    let disposeTexture = function() {
      bufferTexture.dispose();
      morphTextures.delete(geometry);
      geometry.removeEventListener("dispose", disposeTexture);
    };
    if (entry !== void 0)
      entry.texture.dispose();
    const morphTargets = geometry.morphAttributes.position || [];
    const morphNormals = geometry.morphAttributes.normal || [];
    const morphColors = geometry.morphAttributes.color || [];
    let vertexDataCount = 0;
    if (hasMorphPosition === true)
      vertexDataCount = 1;
    if (hasMorphNormals === true)
      vertexDataCount = 2;
    if (hasMorphColors === true)
      vertexDataCount = 3;
    let width = geometry.attributes.position.count * vertexDataCount;
    let height = 1;
    const maxTextureSize = 4096;
    if (width > maxTextureSize) {
      height = Math.ceil(width / maxTextureSize);
      width = maxTextureSize;
    }
    const buffer2 = new Float32Array(width * height * 4 * morphTargetsCount);
    const bufferTexture = new DataArrayTexture(buffer2, width, height, morphTargetsCount);
    bufferTexture.type = FloatType;
    bufferTexture.needsUpdate = true;
    const vertexDataStride = vertexDataCount * 4;
    for (let i = 0; i < morphTargetsCount; i++) {
      const morphTarget = morphTargets[i];
      const morphNormal = morphNormals[i];
      const morphColor = morphColors[i];
      const offset = width * height * 4 * i;
      for (let j = 0; j < morphTarget.count; j++) {
        const stride = j * vertexDataStride;
        if (hasMorphPosition === true) {
          morphVec4.fromBufferAttribute(morphTarget, j);
          buffer2[offset + stride + 0] = morphVec4.x;
          buffer2[offset + stride + 1] = morphVec4.y;
          buffer2[offset + stride + 2] = morphVec4.z;
          buffer2[offset + stride + 3] = 0;
        }
        if (hasMorphNormals === true) {
          morphVec4.fromBufferAttribute(morphNormal, j);
          buffer2[offset + stride + 4] = morphVec4.x;
          buffer2[offset + stride + 5] = morphVec4.y;
          buffer2[offset + stride + 6] = morphVec4.z;
          buffer2[offset + stride + 7] = 0;
        }
        if (hasMorphColors === true) {
          morphVec4.fromBufferAttribute(morphColor, j);
          buffer2[offset + stride + 8] = morphVec4.x;
          buffer2[offset + stride + 9] = morphVec4.y;
          buffer2[offset + stride + 10] = morphVec4.z;
          buffer2[offset + stride + 11] = morphColor.itemSize === 4 ? morphVec4.w : 1;
        }
      }
    }
    entry = {
      count: morphTargetsCount,
      texture: bufferTexture,
      stride: vertexDataCount,
      size: new Vector2(width, height)
    };
    morphTextures.set(geometry, entry);
    geometry.addEventListener("dispose", disposeTexture);
  }
  return entry;
}
var MorphNode = class extends Node_default {
  constructor(mesh) {
    super("void");
    this.mesh = mesh;
    this.morphBaseInfluence = uniform(1);
    this.updateType = NodeUpdateType.OBJECT;
  }
  setup(builder) {
    const { geometry } = builder;
    const hasMorphPosition = geometry.morphAttributes.position !== void 0;
    const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    const { texture: bufferMap, stride, size } = getEntry(geometry);
    if (hasMorphPosition === true)
      positionLocal.mulAssign(this.morphBaseInfluence);
    if (hasMorphNormals === true)
      normalLocal.mulAssign(this.morphBaseInfluence);
    const width = int(size.width);
    for (let i = 0; i < morphTargetsCount; i++) {
      const influence = referenceIndex("morphTargetInfluences", i, "float");
      const depth2 = int(i);
      if (hasMorphPosition === true) {
        positionLocal.addAssign(getMorph({
          bufferMap,
          influence,
          stride,
          width,
          depth: depth2,
          offset: int(0)
        }));
      }
      if (hasMorphNormals === true) {
        normalLocal.addAssign(getMorph({
          bufferMap,
          influence,
          stride,
          width,
          depth: depth2,
          offset: int(1)
        }));
      }
    }
  }
  update() {
    const morphBaseInfluence = this.morphBaseInfluence;
    if (this.mesh.geometry.morphTargetsRelative) {
      morphBaseInfluence.value = 1;
    } else {
      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);
    }
  }
};
var MorphNode_default = MorphNode;
var morph = nodeProxy(MorphNode);
addNodeClass("MorphNode", MorphNode);

// node_modules/three/examples/jsm/nodes/accessors/ReflectVectorNode.js
var ReflectVectorNode = class extends Node_default {
  constructor() {
    super("vec3");
  }
  getHash() {
    return "reflectVector";
  }
  setup() {
    const reflectView = positionViewDirection.negate().reflect(transformedNormalView);
    return reflectView.transformDirection(cameraViewMatrix);
  }
};
var ReflectVectorNode_default = ReflectVectorNode;
var reflectVector = nodeImmutable(ReflectVectorNode);
addNodeClass("ReflectVectorNode", ReflectVectorNode);

// node_modules/three/examples/jsm/nodes/accessors/CubeTextureNode.js
var CubeTextureNode = class extends TextureNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isCubeTextureNode = true;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return reflectVector;
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  generateUV(builder, uvNode) {
    const cubeUV = vec3(uvNode.x.negate(), uvNode.yz);
    return cubeUV.build(builder, "vec3");
  }
};
var CubeTextureNode_default = CubeTextureNode;
var cubeTexture = nodeProxy(CubeTextureNode);
addNodeElement("cubeTexture", cubeTexture);
addNodeClass("CubeTextureNode", CubeTextureNode);

// node_modules/three/examples/jsm/nodes/lighting/LightingNode.js
var LightingNode = class extends Node_default {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var LightingNode_default = LightingNode;
addNodeClass("LightingNode", LightingNode);

// node_modules/three/examples/jsm/nodes/lighting/AnalyticLightNode.js
var depthMaterial = null;
var AnalyticLightNode = class extends LightingNode_default {
  constructor(light = null) {
    super();
    this.updateType = NodeUpdateType.FRAME;
    this.light = light;
    this.rtt = null;
    this.shadowNode = null;
    this.color = new Color();
    this._defaultColorNode = uniform(this.color);
    this.colorNode = this._defaultColorNode;
    this.isAnalyticLightNode = true;
  }
  getCacheKey() {
    return super.getCacheKey() + "-" + (this.light.id + "-" + (this.light.castShadow ? "1" : "0"));
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(builder) {
    let shadowNode = this.shadowNode;
    if (shadowNode === null) {
      if (depthMaterial === null)
        depthMaterial = builder.createNodeMaterial("MeshBasicNodeMaterial");
      const shadow = this.light.shadow;
      const rtt = builder.getRenderTarget(shadow.mapSize.width, shadow.mapSize.height);
      const depthTexture2 = new DepthTexture();
      depthTexture2.minFilter = NearestFilter;
      depthTexture2.magFilter = NearestFilter;
      depthTexture2.image.width = shadow.mapSize.width;
      depthTexture2.image.height = shadow.mapSize.height;
      depthTexture2.compareFunction = LessCompare;
      rtt.depthTexture = depthTexture2;
      shadow.camera.updateProjectionMatrix();
      const bias = reference("bias", "float", shadow);
      const normalBias = reference("normalBias", "float", shadow);
      let shadowCoord = uniform(shadow.matrix).mul(positionWorld.add(normalWorld.mul(normalBias)));
      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
      const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));
      let coordZ = shadowCoord.z.add(bias);
      if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {
        coordZ = coordZ.mul(2).sub(1);
      }
      shadowCoord = vec3(
        shadowCoord.x,
        shadowCoord.y.oneMinus(),
        // follow webgpu standards
        coordZ
      );
      const textureCompare = (depthTexture3, shadowCoord2, compare) => texture(depthTexture3, shadowCoord2).compare(compare);
      shadowNode = textureCompare(depthTexture2, shadowCoord.xy, shadowCoord.z);
      this.rtt = rtt;
      this.colorNode = this.colorNode.mul(frustumTest.mix(1, shadowNode));
      this.shadowNode = shadowNode;
      this.updateBeforeType = NodeUpdateType.RENDER;
    }
  }
  setup(builder) {
    if (this.light.castShadow)
      this.setupShadow(builder);
    else if (this.shadowNode !== null)
      this.disposeShadow();
  }
  updateShadow(frame) {
    const { rtt, light } = this;
    const { renderer, scene } = frame;
    const currentOverrideMaterial = scene.overrideMaterial;
    scene.overrideMaterial = depthMaterial;
    rtt.setSize(light.shadow.mapSize.width, light.shadow.mapSize.height);
    light.shadow.updateMatrices(light);
    const currentRenderTarget = renderer.getRenderTarget();
    const currentRenderObjectFunction = renderer.getRenderObjectFunction();
    renderer.setRenderObjectFunction((object, ...params) => {
      if (object.castShadow === true) {
        renderer.renderObject(object, ...params);
      }
    });
    renderer.setRenderTarget(rtt);
    renderer.render(scene, light.shadow.camera);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setRenderObjectFunction(currentRenderObjectFunction);
    scene.overrideMaterial = currentOverrideMaterial;
  }
  disposeShadow() {
    this.rtt.dispose();
    this.shadowNode = null;
    this.rtt = null;
    this.colorNode = this._defaultColorNode;
  }
  updateBefore(frame) {
    const { light } = this;
    if (light.castShadow)
      this.updateShadow(frame);
  }
  update() {
    const { light } = this;
    this.color.copy(light.color).multiplyScalar(light.intensity);
  }
};
var AnalyticLightNode_default = AnalyticLightNode;
addNodeClass("AnalyticLightNode", AnalyticLightNode);

// node_modules/three/examples/jsm/nodes/lighting/LightsNode.js
var LightNodes = /* @__PURE__ */ new WeakMap();
var sortLights = (lights2) => {
  return lights2.sort((a, b) => a.id - b.id);
};
var LightsNode = class extends Node_default {
  constructor(lightNodes2 = []) {
    super("vec3");
    this.totalDiffuseNode = vec3().temp("totalDiffuse");
    this.totalSpecularNode = vec3().temp("totalSpecular");
    this.outgoingLightNode = vec3().temp("outgoingLight");
    this.lightNodes = lightNodes2;
    this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  getHash() {
    if (this._hash === null) {
      const hash2 = [];
      for (const lightNode of this.lightNodes) {
        hash2.push(lightNode.getHash());
      }
      this._hash = "lights-" + hash2.join(",");
    }
    return this._hash;
  }
  setup(builder) {
    const context2 = builder.context;
    const lightingModel = context2.lightingModel;
    let outgoingLightNode = this.outgoingLightNode;
    if (lightingModel) {
      const { lightNodes: lightNodes2, totalDiffuseNode, totalSpecularNode } = this;
      context2.outgoingLight = outgoingLightNode;
      const stack2 = builder.addStack();
      lightingModel.start(context2, stack2, builder);
      for (const lightNode of lightNodes2) {
        lightNode.build(builder);
      }
      lightingModel.indirectDiffuse(context2, stack2, builder);
      lightingModel.indirectSpecular(context2, stack2, builder);
      lightingModel.ambientOcclusion(context2, stack2, builder);
      const { backdrop, backdropAlpha } = context2;
      const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context2.reflectedLight;
      let totalDiffuse = directDiffuse.add(indirectDiffuse);
      if (backdrop !== null) {
        totalDiffuse = vec3(backdropAlpha !== null ? backdropAlpha.mix(totalDiffuse, backdrop) : backdrop);
      }
      totalDiffuseNode.assign(totalDiffuse);
      totalSpecularNode.assign(directSpecular.add(indirectSpecular));
      outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));
      lightingModel.finish(context2, stack2, builder);
      outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());
    }
    return outgoingLightNode;
  }
  _getLightNodeById(id2) {
    for (const lightNode of this.lightNodes) {
      if (lightNode.isAnalyticLightNode && lightNode.light.id === id2) {
        return lightNode;
      }
    }
    return null;
  }
  fromLights(lights2 = []) {
    const lightNodes2 = [];
    lights2 = sortLights(lights2);
    for (const light of lights2) {
      let lightNode = this._getLightNodeById(light.id);
      if (lightNode === null) {
        const lightClass = light.constructor;
        const lightNodeClass = LightNodes.has(lightClass) ? LightNodes.get(lightClass) : AnalyticLightNode_default;
        lightNode = nodeObject(new lightNodeClass(light));
      }
      lightNodes2.push(lightNode);
    }
    this.lightNodes = lightNodes2;
    this._hash = null;
    return this;
  }
};
var LightsNode_default = LightsNode;
var lights = (lights2) => nodeObject(new LightsNode().fromLights(lights2));
var lightNodes = nodeProxy(LightsNode);
function addLightNode(lightClass, lightNodeClass) {
  if (LightNodes.has(lightClass))
    throw new Error(`Redefinition of light node ${lightNodeClass.type}`);
  if (typeof lightClass !== "function")
    throw new Error(`Light ${lightClass.name} is not a class`);
  if (typeof lightNodeClass !== "function" || !lightNodeClass.type)
    throw new Error(`Light node ${lightNodeClass.type} is not a class`);
  LightNodes.set(lightClass, lightNodeClass);
}

// node_modules/three/examples/jsm/nodes/lighting/AONode.js
var AONode = class extends LightingNode_default {
  constructor(aoNode = null) {
    super();
    this.aoNode = aoNode;
  }
  setup(builder) {
    const aoIntensity = 1;
    const aoNode = this.aoNode.x.sub(1).mul(aoIntensity).add(1);
    builder.context.ambientOcclusion.mulAssign(aoNode);
  }
};
var AONode_default = AONode;
addNodeClass("AONode", AONode);

// node_modules/three/examples/jsm/nodes/lighting/LightingContextNode.js
var LightingContextNode = class extends ContextNode_default {
  constructor(node, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
    super(node);
    this.lightingModel = lightingModel;
    this.backdropNode = backdropNode;
    this.backdropAlphaNode = backdropAlphaNode;
    this._context = null;
  }
  getContext() {
    const { backdropNode, backdropAlphaNode } = this;
    const directDiffuse = vec3().temp("directDiffuse"), directSpecular = vec3().temp("directSpecular"), indirectDiffuse = vec3().temp("indirectDiffuse"), indirectSpecular = vec3().temp("indirectSpecular");
    const reflectedLight = {
      directDiffuse,
      directSpecular,
      indirectDiffuse,
      indirectSpecular
    };
    const context2 = {
      radiance: vec3().temp("radiance"),
      irradiance: vec3().temp("irradiance"),
      iblIrradiance: vec3().temp("iblIrradiance"),
      ambientOcclusion: float(1).temp("ambientOcclusion"),
      reflectedLight,
      backdrop: backdropNode,
      backdropAlpha: backdropAlphaNode
    };
    return context2;
  }
  setup(builder) {
    this.context = this._context || (this._context = this.getContext());
    this.context.lightingModel = this.lightingModel || builder.context.lightingModel;
    return super.setup(builder);
  }
};
var LightingContextNode_default = LightingContextNode;
var lightingContext = nodeProxy(LightingContextNode);
addNodeElement("lightingContext", lightingContext);
addNodeClass("LightingContextNode", LightingContextNode);

// node_modules/three/examples/jsm/nodes/utils/EquirectUVNode.js
var EquirectUVNode = class extends TempNode_default {
  constructor(dirNode = positionWorldDirection) {
    super("vec2");
    this.dirNode = dirNode;
  }
  setup() {
    const dir = this.dirNode;
    const u = dir.z.atan2(dir.x).mul(1 / (Math.PI * 2)).add(0.5);
    const v = dir.y.negate().clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return vec2(u, v);
  }
};
var EquirectUVNode_default = EquirectUVNode;
var equirectUV = nodeProxy(EquirectUVNode);
addNodeClass("EquirectUVNode", EquirectUVNode);

// node_modules/three/examples/jsm/nodes/utils/SpecularMIPLevelNode.js
var SpecularMIPLevelNode = class extends Node_default {
  constructor(textureNode, roughnessNode = null) {
    super("float");
    this.textureNode = textureNode;
    this.roughnessNode = roughnessNode;
  }
  setup() {
    const { textureNode, roughnessNode } = this;
    const maxMIPLevelScalar = maxMipLevel(textureNode);
    const sigma = roughnessNode.mul(roughnessNode).mul(Math.PI).div(roughnessNode.add(1));
    const desiredMIPLevel = maxMIPLevelScalar.add(sigma.log2());
    return desiredMIPLevel.clamp(0, maxMIPLevelScalar);
  }
};
var SpecularMIPLevelNode_default = SpecularMIPLevelNode;
var specularMIPLevel = nodeProxy(SpecularMIPLevelNode);
addNodeClass("SpecularMIPLevelNode", SpecularMIPLevelNode);

// node_modules/three/examples/jsm/nodes/lighting/EnvironmentNode.js
var envNodeCache = /* @__PURE__ */ new WeakMap();
var EnvironmentNode = class extends LightingNode_default {
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  setup(builder) {
    let envNode = this.envNode;
    if (envNode.isTextureNode && envNode.value.isCubeTexture !== true) {
      let cacheEnvNode = envNodeCache.get(envNode.value);
      if (cacheEnvNode === void 0) {
        const texture2 = envNode.value;
        const renderer = builder.renderer;
        const cubeRTT = builder.getCubeRenderTarget(512).fromEquirectangularTexture(renderer, texture2);
        cacheEnvNode = cubeTexture(cubeRTT.texture);
        envNodeCache.set(envNode.value, cacheEnvNode);
      }
      envNode = cacheEnvNode;
    }
    const intensity = reference("envMapIntensity", "float", builder.material);
    const radiance = context(envNode, createRadianceContext(roughness, transformedNormalView)).mul(intensity);
    const irradiance = context(envNode, createIrradianceContext(transformedNormalWorld)).mul(Math.PI).mul(intensity);
    const isolateRadiance = cache(radiance);
    builder.context.radiance.addAssign(isolateRadiance);
    builder.context.iblIrradiance.addAssign(irradiance);
    const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;
    if (clearcoatRadiance) {
      const clearcoatRadianceContext = context(envNode, createRadianceContext(clearcoatRoughness, transformedClearcoatNormalView)).mul(intensity);
      const isolateClearcoatRadiance = cache(clearcoatRadianceContext);
      clearcoatRadiance.addAssign(isolateClearcoatRadiance);
    }
  }
};
var createRadianceContext = (roughnessNode, normalViewNode) => {
  let reflectVec = null;
  let textureUVNode = null;
  return {
    getUV: (textureNode) => {
      let node = null;
      if (reflectVec === null) {
        reflectVec = positionViewDirection.negate().reflect(normalViewNode);
        reflectVec = roughnessNode.mul(roughnessNode).mix(reflectVec, normalViewNode).normalize();
        reflectVec = reflectVec.transformDirection(cameraViewMatrix);
      }
      if (textureNode.isCubeTextureNode) {
        node = reflectVec;
      } else if (textureNode.isTextureNode) {
        if (textureUVNode === null) {
          textureUVNode = equirectUV(reflectVec);
        }
        node = textureUVNode;
      }
      return node;
    },
    getTextureLevel: () => {
      return roughnessNode;
    },
    getTextureLevelAlgorithm: (textureNode, levelNode) => {
      return specularMIPLevel(textureNode, levelNode);
    }
  };
};
var createIrradianceContext = (normalWorldNode) => {
  let textureUVNode = null;
  return {
    getUV: (textureNode) => {
      let node = null;
      if (textureNode.isCubeTextureNode) {
        node = normalWorldNode;
      } else if (textureNode.isTextureNode) {
        if (textureUVNode === null) {
          textureUVNode = equirectUV(normalWorldNode);
          textureUVNode = vec2(textureUVNode.x, textureUVNode.y.oneMinus());
        }
        node = textureUVNode;
      }
      return node;
    },
    getTextureLevel: (textureNode) => {
      return maxMipLevel(textureNode);
    }
  };
};
var EnvironmentNode_default = EnvironmentNode;
addNodeClass("EnvironmentNode", EnvironmentNode);

// node_modules/three/examples/jsm/nodes/display/ViewportNode.js
var resolution;
var viewportResult;
var ViewportNode = class _ViewportNode extends Node_default {
  constructor(scope) {
    super();
    this.scope = scope;
    this.isViewportNode = true;
  }
  getNodeType() {
    return this.scope === _ViewportNode.VIEWPORT ? "vec4" : "vec2";
  }
  getUpdateType() {
    let updateType = NodeUpdateType.NONE;
    if (this.scope === _ViewportNode.RESOLUTION || this.scope === _ViewportNode.VIEWPORT) {
      updateType = NodeUpdateType.FRAME;
    }
    this.updateType = updateType;
    return updateType;
  }
  update({ renderer }) {
    if (this.scope === _ViewportNode.VIEWPORT) {
      renderer.getViewport(viewportResult);
    } else {
      renderer.getDrawingBufferSize(resolution);
    }
  }
  setup() {
    const scope = this.scope;
    if (scope === _ViewportNode.COORDINATE)
      return;
    let output2 = null;
    if (scope === _ViewportNode.RESOLUTION) {
      output2 = uniform(resolution || (resolution = new Vector2()));
    } else if (scope === _ViewportNode.VIEWPORT) {
      output2 = uniform(viewportResult || (viewportResult = new Vector4()));
    } else {
      output2 = viewportCoordinate.div(viewportResolution);
      let outX = output2.x;
      let outY = output2.y;
      if (/bottom/i.test(scope))
        outY = outY.oneMinus();
      if (/right/i.test(scope))
        outX = outX.oneMinus();
      output2 = vec2(outX, outY);
    }
    return output2;
  }
  generate(builder) {
    if (this.scope === _ViewportNode.COORDINATE) {
      let coord = builder.getFragCoord();
      if (builder.isFlipY()) {
        const resolution2 = builder.getNodeProperties(viewportResolution).outputNode.build(builder);
        coord = `${builder.getType("vec2")}( ${coord}.x, ${resolution2}.y - ${coord}.y )`;
      }
      return coord;
    }
    return super.generate(builder);
  }
};
ViewportNode.COORDINATE = "coordinate";
ViewportNode.RESOLUTION = "resolution";
ViewportNode.VIEWPORT = "viewport";
ViewportNode.TOP_LEFT = "topLeft";
ViewportNode.BOTTOM_LEFT = "bottomLeft";
ViewportNode.TOP_RIGHT = "topRight";
ViewportNode.BOTTOM_RIGHT = "bottomRight";
var ViewportNode_default = ViewportNode;
var viewportCoordinate = nodeImmutable(ViewportNode, ViewportNode.COORDINATE);
var viewportResolution = nodeImmutable(ViewportNode, ViewportNode.RESOLUTION);
var viewport = nodeImmutable(ViewportNode, ViewportNode.VIEWPORT);
var viewportTopLeft = nodeImmutable(ViewportNode, ViewportNode.TOP_LEFT);
var viewportBottomLeft = nodeImmutable(ViewportNode, ViewportNode.BOTTOM_LEFT);
var viewportTopRight = nodeImmutable(ViewportNode, ViewportNode.TOP_RIGHT);
var viewportBottomRight = nodeImmutable(ViewportNode, ViewportNode.BOTTOM_RIGHT);
addNodeClass("ViewportNode", ViewportNode);

// node_modules/three/examples/jsm/nodes/display/ViewportTextureNode.js
var _size = new Vector2();
var ViewportTextureNode = class extends TextureNode_default {
  constructor(uvNode = viewportTopLeft, levelNode = null, framebufferTexture = null) {
    if (framebufferTexture === null) {
      framebufferTexture = new FramebufferTexture();
      framebufferTexture.minFilter = LinearMipmapLinearFilter;
    }
    super(framebufferTexture, uvNode, levelNode);
    this.generateMipmaps = false;
    this.isOutputTextureNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
  }
  updateBefore(frame) {
    const renderer = frame.renderer;
    renderer.getDrawingBufferSize(_size);
    const framebufferTexture = this.value;
    if (framebufferTexture.image.width !== _size.width || framebufferTexture.image.height !== _size.height) {
      framebufferTexture.image.width = _size.width;
      framebufferTexture.image.height = _size.height;
      framebufferTexture.needsUpdate = true;
    }
    const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
    framebufferTexture.generateMipmaps = this.generateMipmaps;
    renderer.copyFramebufferToTexture(framebufferTexture);
    framebufferTexture.generateMipmaps = currentGenerateMipmaps;
  }
  clone() {
    return new this.constructor(this.uvNode, this.levelNode, this.value);
  }
};
var ViewportTextureNode_default = ViewportTextureNode;
var viewportTexture = nodeProxy(ViewportTextureNode);
var viewportMipTexture = nodeProxy(ViewportTextureNode, null, null, { generateMipmaps: true });
addNodeElement("viewportTexture", viewportTexture);
addNodeElement("viewportMipTexture", viewportMipTexture);
addNodeClass("ViewportTextureNode", ViewportTextureNode);

// node_modules/three/examples/jsm/nodes/display/ViewportDepthTextureNode.js
var sharedDepthbuffer = null;
var ViewportDepthTextureNode = class extends ViewportTextureNode_default {
  constructor(uvNode = viewportTopLeft, levelNode = null) {
    if (sharedDepthbuffer === null) {
      sharedDepthbuffer = new DepthTexture();
      sharedDepthbuffer.minFilter = NearestMipmapNearestFilter;
      sharedDepthbuffer.type = UnsignedIntType;
      sharedDepthbuffer.format = DepthFormat;
    }
    super(uvNode, levelNode, sharedDepthbuffer);
  }
};
var ViewportDepthTextureNode_default = ViewportDepthTextureNode;
var viewportDepthTexture = nodeProxy(ViewportDepthTextureNode);
addNodeElement("viewportDepthTexture", viewportDepthTexture);
addNodeClass("ViewportDepthTextureNode", ViewportDepthTextureNode);

// node_modules/three/examples/jsm/nodes/display/ViewportDepthNode.js
var ViewportDepthNode = class _ViewportDepthNode extends Node_default {
  constructor(scope, valueNode = null) {
    super("float");
    this.scope = scope;
    this.valueNode = valueNode;
    this.isViewportDepthNode = true;
  }
  generate(builder) {
    const { scope } = this;
    if (scope === _ViewportDepthNode.DEPTH_PIXEL) {
      return builder.getFragDepth();
    }
    return super.generate(builder);
  }
  setup() {
    const { scope } = this;
    let node = null;
    if (scope === _ViewportDepthNode.DEPTH) {
      node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
    } else if (scope === _ViewportDepthNode.DEPTH_TEXTURE) {
      const texture2 = this.valueNode || viewportDepthTexture();
      const viewZ = perspectiveDepthToViewZ(texture2, cameraNear, cameraFar);
      node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
    } else if (scope === _ViewportDepthNode.DEPTH_PIXEL) {
      if (this.valueNode !== null) {
        node = depthPixelBase().assign(this.valueNode);
      }
    }
    return node;
  }
};
var viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));
var orthographicDepthToViewZ = (depth2, near, far) => near.sub(far).mul(depth2).sub(near);
var viewZToPerspectiveDepth = (viewZ, near, far) => near.add(viewZ).mul(far).div(near.sub(far).mul(viewZ));
var perspectiveDepthToViewZ = (depth2, near, far) => near.mul(far).div(far.sub(near).mul(depth2).sub(far));
ViewportDepthNode.DEPTH = "depth";
ViewportDepthNode.DEPTH_TEXTURE = "depthTexture";
ViewportDepthNode.DEPTH_PIXEL = "depthPixel";
var ViewportDepthNode_default = ViewportDepthNode;
var depthPixelBase = nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_PIXEL);
var depth = nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);
var depthTexture = nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_TEXTURE);
var depthPixel = nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH_PIXEL);
depthPixel.assign = (value) => depthPixelBase(value);
addNodeClass("ViewportDepthNode", ViewportDepthNode);

// node_modules/three/examples/jsm/nodes/materials/NodeMaterial.js
var NodeMaterials = /* @__PURE__ */ new Map();
var NodeMaterial = class extends ShaderMaterial {
  constructor() {
    super();
    this.isNodeMaterial = true;
    this.type = this.constructor.type;
    this.forceSinglePass = false;
    this.fog = true;
    this.lights = true;
    this.normals = true;
    this.colorSpaced = true;
    this.lightsNode = null;
    this.envNode = null;
    this.colorNode = null;
    this.normalNode = null;
    this.opacityNode = null;
    this.backdropNode = null;
    this.backdropAlphaNode = null;
    this.alphaTestNode = null;
    this.positionNode = null;
    this.depthNode = null;
    this.outputNode = null;
    this.fragmentNode = null;
    this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + getCacheKey(this);
  }
  build(builder) {
    this.setup(builder);
  }
  setup(builder) {
    builder.addStack();
    builder.stack.outputNode = this.vertexNode || this.setupPosition(builder);
    builder.addFlow("vertex", builder.removeStack());
    builder.addStack();
    let resultNode;
    if (this.fragmentNode === null) {
      if (this.depthWrite === true)
        this.setupDepth(builder);
      if (this.normals === true)
        this.setupNormal(builder);
      this.setupDiffuseColor(builder);
      this.setupVariants(builder);
      const outgoingLightNode = this.setupLighting(builder);
      resultNode = this.setupOutput(builder, vec4(outgoingLightNode, diffuseColor.a));
      output.assign(resultNode);
      if (this.outputNode !== null)
        resultNode = this.outputNode;
    } else {
      resultNode = this.setupOutput(builder, this.fragmentNode);
    }
    builder.stack.outputNode = resultNode;
    builder.addFlow("fragment", builder.removeStack());
  }
  setupDepth(builder) {
    const { renderer } = builder;
    let depthNode = this.depthNode;
    if (depthNode === null && renderer.logarithmicDepthBuffer === true) {
      const fragDepth = modelViewProjection().w.add(1);
      depthNode = fragDepth.log2().mul(cameraLogDepth).mul(0.5);
    }
    if (depthNode !== null) {
      depthPixel.assign(depthNode).append();
    }
  }
  setupPosition(builder) {
    const { object } = builder;
    const geometry = object.geometry;
    builder.addStack();
    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {
      morph(object).append();
    }
    if (object.isSkinnedMesh === true) {
      skinning(object).append();
    }
    if (object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true && builder.isAvailable("instance") === true) {
      instance(object).append();
    }
    if (this.positionNode !== null) {
      positionLocal.assign(this.positionNode);
    }
    const mvp = modelViewProjection();
    builder.context.vertex = builder.removeStack();
    builder.context.mvp = mvp;
    return mvp;
  }
  setupDiffuseColor({ geometry }) {
    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;
    if (this.vertexColors === true && geometry.hasAttribute("color")) {
      colorNode = vec4(colorNode.xyz.mul(attribute("color", "vec3")), colorNode.a);
    }
    diffuseColor.assign(colorNode);
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));
    if (this.alphaTestNode !== null || this.alphaTest > 0) {
      const alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;
      diffuseColor.a.lessThanEqual(alphaTestNode).discard();
    }
  }
  setupVariants() {
  }
  setupNormal() {
    if (this.flatShading === true) {
      const normalNode = positionView.dFdx().cross(positionView.dFdy()).normalize();
      transformedNormalView.assign(normalNode);
    } else {
      const normalNode = this.normalNode ? vec3(this.normalNode) : materialNormal;
      transformedNormalView.assign(normalNode);
    }
  }
  getEnvNode(builder) {
    let node = null;
    if (this.envNode) {
      node = this.envNode;
    } else if (this.envMap) {
      node = this.envMap.isCubeTexture ? cubeTexture(this.envMap) : texture(this.envMap);
    } else if (builder.environmentNode) {
      node = builder.environmentNode;
    }
    return node;
  }
  setupLights(builder) {
    const envNode = this.getEnvNode(builder);
    const materialLightsNode = [];
    if (envNode) {
      materialLightsNode.push(new EnvironmentNode_default(envNode));
    }
    if (builder.material.aoMap) {
      materialLightsNode.push(new AONode_default(texture(builder.material.aoMap)));
    }
    let lightsNode = this.lightsNode || builder.lightsNode;
    if (materialLightsNode.length > 0) {
      lightsNode = lightNodes([...lightsNode.lightNodes, ...materialLightsNode]);
    }
    return lightsNode;
  }
  setupLightingModel() {
  }
  setupLighting(builder) {
    const { material } = builder;
    const { backdropNode, backdropAlphaNode, emissiveNode } = this;
    const lights2 = this.lights === true || this.lightsNode !== null;
    const lightsNode = lights2 ? this.setupLights(builder) : null;
    let outgoingLightNode = diffuseColor.rgb;
    if (lightsNode && lightsNode.hasLight !== false) {
      const lightingModel = this.setupLightingModel(builder);
      outgoingLightNode = lightingContext(lightsNode, lightingModel, backdropNode, backdropAlphaNode);
    } else if (backdropNode !== null) {
      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);
    }
    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {
      outgoingLightNode = outgoingLightNode.add(vec3(emissiveNode ? emissiveNode : materialEmissive));
    }
    return outgoingLightNode;
  }
  setupOutput(builder, outputNode) {
    const renderer = builder.renderer;
    const toneMappingNode = builder.toneMappingNode;
    if (toneMappingNode) {
      outputNode = vec4(toneMappingNode.context({ color: outputNode.rgb }), outputNode.a);
    }
    if (this.fog === true) {
      const fogNode = builder.fogNode;
      if (fogNode)
        outputNode = vec4(fogNode.mixAssign(outputNode.rgb), outputNode.a);
    }
    if (this.colorSpaced === true) {
      const outputColorSpace = renderer.currentColorSpace;
      if (outputColorSpace !== LinearSRGBColorSpace && outputColorSpace !== NoColorSpace) {
        outputNode = outputNode.linearToColorSpace(outputColorSpace);
      }
    }
    return outputNode;
  }
  setDefaultValues(material) {
    for (const property2 in material) {
      const value = material[property2];
      if (this[property2] === void 0) {
        this[property2] = value;
        if (value && value.clone)
          this[property2] = value.clone();
      }
    }
    Object.assign(this.defines, material.defines);
    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);
    for (const key in descriptors) {
      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === void 0 && descriptors[key].get !== void 0) {
        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);
      }
    }
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    const nodeChildren = getNodeChildren(this);
    data.inputNodes = {};
    for (const { property: property2, childNode } of nodeChildren) {
      data.inputNodes[property2] = childNode.toJSON(meta).uuid;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
  copy(source) {
    this.lightsNode = source.lightsNode;
    this.envNode = source.envNode;
    this.colorNode = source.colorNode;
    this.normalNode = source.normalNode;
    this.opacityNode = source.opacityNode;
    this.backdropNode = source.backdropNode;
    this.backdropAlphaNode = source.backdropAlphaNode;
    this.alphaTestNode = source.alphaTestNode;
    this.positionNode = source.positionNode;
    this.depthNode = source.depthNode;
    this.outputNode = source.outputNode;
    this.fragmentNode = source.fragmentNode;
    this.vertexNode = source.vertexNode;
    return super.copy(source);
  }
  static fromMaterial(material) {
    if (material.isNodeMaterial === true) {
      return material;
    }
    const type = material.type.replace("Material", "NodeMaterial");
    const nodeMaterial = createNodeMaterialFromType(type);
    if (nodeMaterial === void 0) {
      throw new Error(`NodeMaterial: Material "${material.type}" is not compatible.`);
    }
    for (const key in material) {
      nodeMaterial[key] = material[key];
    }
    return nodeMaterial;
  }
};
var NodeMaterial_default = NodeMaterial;
function addNodeMaterial(type, nodeMaterial) {
  if (typeof nodeMaterial !== "function" || !type)
    throw new Error(`Node material ${type} is not a class`);
  if (NodeMaterials.has(type))
    throw new Error(`Redefinition of node material ${type}`);
  NodeMaterials.set(type, nodeMaterial);
  nodeMaterial.type = type;
}
function createNodeMaterialFromType(type) {
  const Material2 = NodeMaterials.get(type);
  if (Material2 !== void 0) {
    return new Material2();
  }
}
addNodeMaterial("NodeMaterial", NodeMaterial);

// node_modules/three/examples/jsm/renderers/common/Uniform.js
var Uniform = class {
  constructor(name, value = null) {
    this.name = name;
    this.value = value;
    this.boundary = 0;
    this.itemSize = 0;
    this.offset = 0;
  }
  setValue(value) {
    this.value = value;
  }
  getValue() {
    return this.value;
  }
};
var FloatUniform = class extends Uniform {
  constructor(name, value = 0) {
    super(name, value);
    this.isFloatUniform = true;
    this.boundary = 4;
    this.itemSize = 1;
  }
};
var Vector2Uniform = class extends Uniform {
  constructor(name, value = new Vector2()) {
    super(name, value);
    this.isVector2Uniform = true;
    this.boundary = 8;
    this.itemSize = 2;
  }
};
var Vector3Uniform = class extends Uniform {
  constructor(name, value = new Vector3()) {
    super(name, value);
    this.isVector3Uniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Vector4Uniform = class extends Uniform {
  constructor(name, value = new Vector4()) {
    super(name, value);
    this.isVector4Uniform = true;
    this.boundary = 16;
    this.itemSize = 4;
  }
};
var ColorUniform = class extends Uniform {
  constructor(name, value = new Color()) {
    super(name, value);
    this.isColorUniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Matrix3Uniform = class extends Uniform {
  constructor(name, value = new Matrix3()) {
    super(name, value);
    this.isMatrix3Uniform = true;
    this.boundary = 48;
    this.itemSize = 12;
  }
};
var Matrix4Uniform = class extends Uniform {
  constructor(name, value = new Matrix4()) {
    super(name, value);
    this.isMatrix4Uniform = true;
    this.boundary = 64;
    this.itemSize = 16;
  }
};

// node_modules/three/examples/jsm/renderers/common/nodes/NodeUniform.js
var FloatNodeUniform = class extends FloatUniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector2NodeUniform = class extends Vector2Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector3NodeUniform = class extends Vector3Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector4NodeUniform = class extends Vector4Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var ColorNodeUniform = class extends ColorUniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Matrix3NodeUniform = class extends Matrix3Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Matrix4NodeUniform = class extends Matrix4Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};

// node_modules/three/examples/jsm/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    if (this.elseNode !== null) {
      const elseType = this.elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const context2 = { tempWrite: false };
    const { ifNode, elseNode } = this;
    const needsProperty = ifNode.getNodeType(builder) !== "void" || elseNode && elseNode.getNodeType(builder) !== "void";
    const nodeProperty = needsProperty ? property(type).build(builder) : "";
    const nodeSnippet = context(
      this.condNode
      /*, context*/
    ).build(builder, "bool");
    builder.addFlowCode(`
${builder.tab}if ( ${nodeSnippet} ) {

`).addFlowTab();
    let ifSnippet = context(this.ifNode, context2).build(builder, type);
    ifSnippet = needsProperty ? nodeProperty + " = " + ifSnippet + ";" : ifSnippet;
    builder.removeFlowTab().addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
    if (elseNode !== null) {
      builder.addFlowCode(" else {\n\n").addFlowTab();
      let elseSnippet = context(elseNode, context2).build(builder, type);
      elseSnippet = nodeProperty ? nodeProperty + " = " + elseSnippet + ";" : elseSnippet;
      builder.removeFlowTab().addFlowCode(builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n");
    } else {
      builder.addFlowCode("\n\n");
    }
    return nodeProperty;
  }
};
var CondNode_default = CondNode;
var cond = nodeProxy(CondNode);
addNodeElement("cond", cond);
addNodeClass("CondNode", CondNode);

// node_modules/three/examples/jsm/nodes/core/StackNode.js
var StackNode = class extends Node_default {
  constructor(parent = null) {
    super();
    this.nodes = [];
    this.outputNode = null;
    this.parent = parent;
    this._currentCond = null;
    this.isStackNode = true;
  }
  getNodeType(builder) {
    return this.outputNode ? this.outputNode.getNodeType(builder) : "void";
  }
  add(node) {
    this.nodes.push(node);
    return this;
  }
  if(boolNode, method) {
    const methodNode = new ShaderNode(method);
    this._currentCond = cond(boolNode, methodNode);
    return this.add(this._currentCond);
  }
  elseif(boolNode, method) {
    const methodNode = new ShaderNode(method);
    const ifNode = cond(boolNode, methodNode);
    this._currentCond.elseNode = ifNode;
    this._currentCond = ifNode;
    return this;
  }
  else(method) {
    this._currentCond.elseNode = new ShaderNode(method);
    return this;
  }
  build(builder, ...params) {
    const previousStack = getCurrentStack();
    setCurrentStack(this);
    for (const node of this.nodes) {
      node.build(builder, "void");
    }
    setCurrentStack(previousStack);
    return this.outputNode ? this.outputNode.build(builder, ...params) : super.build(builder, ...params);
  }
};
var StackNode_default = StackNode;
var stack = nodeProxy(StackNode);
addNodeClass("StackNode", StackNode);

// node_modules/three/examples/jsm/renderers/common/CubeRenderTarget.js
var CubeRenderTarget = class extends WebGLCubeRenderTarget {
  constructor(size = 1, options = {}) {
    super(size, options);
    this.isCubeRenderTarget = true;
  }
  fromEquirectangularTexture(renderer, texture2) {
    const currentMinFilter = texture2.minFilter;
    const currentGenerateMipmaps = texture2.generateMipmaps;
    texture2.generateMipmaps = true;
    this.texture.type = texture2.type;
    this.texture.colorSpace = texture2.colorSpace;
    this.texture.generateMipmaps = texture2.generateMipmaps;
    this.texture.minFilter = texture2.minFilter;
    this.texture.magFilter = texture2.magFilter;
    const geometry = new BoxGeometry(5, 5, 5);
    const uvNode = equirectUV(positionWorldDirection);
    const material = createNodeMaterialFromType("MeshBasicNodeMaterial");
    material.colorNode = texture(texture2, uvNode, 0);
    material.side = BackSide;
    material.blending = NoBlending;
    const mesh = new Mesh(geometry, material);
    const scene = new Scene();
    scene.add(mesh);
    if (texture2.minFilter === LinearMipmapLinearFilter)
      texture2.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, scene);
    texture2.minFilter = currentMinFilter;
    texture2.currentGenerateMipmaps = currentGenerateMipmaps;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
};
var CubeRenderTarget_default = CubeRenderTarget;

// node_modules/three/examples/jsm/renderers/common/ChainMap.js
var ChainMap = class {
  constructor() {
    this.weakMap = /* @__PURE__ */ new WeakMap();
  }
  get(keys) {
    if (Array.isArray(keys)) {
      let map = this.weakMap;
      for (let i = 0; i < keys.length; i++) {
        map = map.get(keys[i]);
        if (map === void 0)
          return void 0;
      }
      return map.get(keys[keys.length - 1]);
    } else {
      return super.get(keys);
    }
  }
  set(keys, value) {
    if (Array.isArray(keys)) {
      let map = this.weakMap;
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (map.has(key) === false)
          map.set(key, /* @__PURE__ */ new WeakMap());
        map = map.get(key);
      }
      return map.set(keys[keys.length - 1], value);
    } else {
      return super.set(keys, value);
    }
  }
  delete(keys) {
    if (Array.isArray(keys)) {
      let map = this.weakMap;
      for (let i = 0; i < keys.length; i++) {
        map = map.get(keys[i]);
        if (map === void 0)
          return false;
      }
      return map.delete(keys[keys.length - 1]);
    } else {
      return super.delete(keys);
    }
  }
  dispose() {
    this.weakMap.clear();
  }
};

// node_modules/three/examples/jsm/nodes/core/NodeBuilder.js
var uniformsGroupCache = new ChainMap();
var typeFromLength = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]);
var typeFromArray = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]);
var isNonPaddingElementArray = /* @__PURE__ */ new Set([Int32Array, Uint32Array, Float32Array]);
var toFloat = (value) => {
  value = Number(value);
  return value + (value % 1 ? "" : ".0");
};
var NodeBuilder = class {
  constructor(object, renderer, parser, scene = null, material = null) {
    this.object = object;
    this.material = material || object && object.material || null;
    this.geometry = object && object.geometry || null;
    this.renderer = renderer;
    this.parser = parser;
    this.scene = scene;
    this.nodes = [];
    this.updateNodes = [];
    this.updateBeforeNodes = [];
    this.hashNodes = {};
    this.lightsNode = null;
    this.environmentNode = null;
    this.fogNode = null;
    this.toneMappingNode = null;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.computeShader = null;
    this.flowNodes = { vertex: [], fragment: [], compute: [] };
    this.flowCode = { vertex: "", fragment: "", compute: [] };
    this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
    this.structs = { vertex: [], fragment: [], compute: [], index: 0 };
    this.bindings = { vertex: [], fragment: [], compute: [] };
    this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };
    this.bindingsArray = null;
    this.attributes = [];
    this.bufferAttributes = [];
    this.varyings = [];
    this.codes = {};
    this.vars = {};
    this.flow = { code: "" };
    this.chaining = [];
    this.stack = stack();
    this.stacks = [];
    this.tab = "	";
    this.context = {
      keywords: new NodeKeywords_default(),
      material: this.material
    };
    this.cache = new NodeCache_default();
    this.globalCache = this.cache;
    this.flowsData = /* @__PURE__ */ new WeakMap();
    this.shaderStage = null;
    this.buildStage = null;
  }
  getRenderTarget(width, height, options) {
    return new RenderTarget(width, height, options);
  }
  getCubeRenderTarget(size, options) {
    return new CubeRenderTarget_default(size, options);
  }
  includes(node) {
    return this.nodes.includes(node);
  }
  _getSharedBindings(bindings) {
    const shared = [];
    for (const binding of bindings) {
      if (binding.shared === true) {
        const nodes = binding.getNodes();
        let sharedBinding = uniformsGroupCache.get(nodes);
        if (sharedBinding === void 0) {
          uniformsGroupCache.set(nodes, binding);
          sharedBinding = binding;
        }
        shared.push(sharedBinding);
      } else {
        shared.push(binding);
      }
    }
    return shared;
  }
  getBindings() {
    let bindingsArray = this.bindingsArray;
    if (bindingsArray === null) {
      const bindings = this.bindings;
      this.bindingsArray = bindingsArray = this._getSharedBindings(this.material !== null ? [...bindings.vertex, ...bindings.fragment] : bindings.compute);
    }
    return bindingsArray;
  }
  setHashNode(node, hash2) {
    this.hashNodes[hash2] = node;
  }
  addNode(node) {
    if (this.nodes.includes(node) === false) {
      this.nodes.push(node);
      this.setHashNode(node, node.getHash(this));
    }
  }
  buildUpdateNodes() {
    for (const node of this.nodes) {
      const updateType = node.getUpdateType();
      const updateBeforeType = node.getUpdateBeforeType();
      if (updateType !== NodeUpdateType.NONE) {
        this.updateNodes.push(node.getSelf());
      }
      if (updateBeforeType !== NodeUpdateType.NONE) {
        this.updateBeforeNodes.push(node);
      }
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  addChain(node) {
    this.chaining.push(node);
  }
  removeChain(node) {
    const lastChain = this.chaining.pop();
    if (lastChain !== node) {
      throw new Error("NodeBuilder: Invalid node chaining!");
    }
  }
  getMethod(method) {
    return method;
  }
  getNodeFromHash(hash2) {
    return this.hashNodes[hash2];
  }
  addFlow(shaderStage, node) {
    this.flowNodes[shaderStage].push(node);
    return node;
  }
  setContext(context2) {
    this.context = context2;
  }
  getContext() {
    return this.context;
  }
  setCache(cache2) {
    this.cache = cache2;
  }
  getCache() {
    return this.cache;
  }
  isAvailable() {
    return false;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return false;
  }
  generateTexture() {
    console.warn("Abstract function.");
  }
  generateTextureLod() {
    console.warn("Abstract function.");
  }
  generateConst(type, value = null) {
    if (value === null) {
      if (type === "float" || type === "int" || type === "uint")
        value = 0;
      else if (type === "bool")
        value = false;
      else if (type === "color")
        value = new Color();
      else if (type === "vec2")
        value = new Vector2();
      else if (type === "vec3")
        value = new Vector3();
      else if (type === "vec4")
        value = new Vector4();
    }
    if (type === "float")
      return toFloat(value);
    if (type === "int")
      return `${Math.round(value)}`;
    if (type === "uint")
      return value >= 0 ? `${Math.round(value)}u` : "0u";
    if (type === "bool")
      return value ? "true" : "false";
    if (type === "color")
      return `${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
    const typeLength = this.getTypeLength(type);
    const componentType = this.getComponentType(type);
    const generateConst = (value2) => this.generateConst(componentType, value2);
    if (typeLength === 2) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
    } else if (typeLength === 3) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
    } else if (typeLength === 4) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;
    } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {
      return `${this.getType(type)}( ${value.elements.map(generateConst).join(", ")} )`;
    } else if (typeLength > 4) {
      return `${this.getType(type)}()`;
    }
    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
  }
  getType(type) {
    if (type === "color")
      return "vec3";
    return type;
  }
  generateMethod(method) {
    return method;
  }
  hasGeometryAttribute(name) {
    return this.geometry && this.geometry.getAttribute(name) !== void 0;
  }
  getAttribute(name, type) {
    const attributes = this.attributes;
    for (const attribute3 of attributes) {
      if (attribute3.name === name) {
        return attribute3;
      }
    }
    const attribute2 = new NodeAttribute_default(name, type);
    attributes.push(attribute2);
    return attribute2;
  }
  getPropertyName(node) {
    return node.name;
  }
  isVector(type) {
    return /vec\d/.test(type);
  }
  isMatrix(type) {
    return /mat\d/.test(type);
  }
  isReference(type) {
    return type === "void" || type === "property" || type === "sampler" || type === "texture" || type === "cubeTexture";
  }
  needsColorSpaceToLinear() {
    return false;
  }
  /** @deprecated, r152 */
  getTextureEncodingFromMap(map) {
    console.warn("THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.");
    return this.getTextureColorSpaceFromMap(map) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
  }
  getTextureColorSpaceFromMap(map) {
    let colorSpace;
    if (map && map.isTexture) {
      colorSpace = map.colorSpace;
    } else if (map && map.isWebGLRenderTarget) {
      colorSpace = map.texture.colorSpace;
    } else {
      colorSpace = NoColorSpace;
    }
    return colorSpace;
  }
  getComponentType(type) {
    type = this.getVectorType(type);
    if (type === "float" || type === "bool" || type === "int" || type === "uint")
      return type;
    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);
    if (componentType === null)
      return null;
    if (componentType[1] === "b")
      return "bool";
    if (componentType[1] === "i")
      return "int";
    if (componentType[1] === "u")
      return "uint";
    return "float";
  }
  getVectorType(type) {
    if (type === "color")
      return "vec3";
    if (type === "texture")
      return "vec4";
    return type;
  }
  getTypeFromLength(length2, componentType = "float") {
    if (length2 === 1)
      return componentType;
    const baseType = typeFromLength.get(length2);
    const prefix = componentType === "float" ? "" : componentType[0];
    return prefix + baseType;
  }
  getTypeFromArray(array) {
    return typeFromArray.get(array.constructor);
  }
  getTypeFromAttribute(attribute2) {
    let dataAttribute = attribute2;
    if (attribute2.isInterleavedBufferAttribute)
      dataAttribute = attribute2.data;
    const array = dataAttribute.array;
    const itemSize = isNonPaddingElementArray.has(array.constructor) ? attribute2.itemSize : dataAttribute.stride || attribute2.itemSize;
    const normalized = attribute2.normalized;
    let arrayType;
    if (!(attribute2 instanceof Float16BufferAttribute) && normalized !== true) {
      arrayType = this.getTypeFromArray(array);
    }
    return this.getTypeFromLength(itemSize, arrayType);
  }
  getTypeLength(type) {
    const vecType = this.getVectorType(type);
    const vecNum = /vec([2-4])/.exec(vecType);
    if (vecNum !== null)
      return Number(vecNum[1]);
    if (vecType === "float" || vecType === "bool" || vecType === "int" || vecType === "uint")
      return 1;
    if (/mat3/.test(type) === true)
      return 9;
    if (/mat4/.test(type) === true)
      return 16;
    return 0;
  }
  getVectorFromMatrix(type) {
    return type.replace("mat", "vec");
  }
  changeComponentType(type, newComponentType) {
    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
  }
  getIntegerType(type) {
    const componentType = this.getComponentType(type);
    if (componentType === "int" || componentType === "uint")
      return type;
    return this.changeComponentType(type, "int");
  }
  addStack() {
    this.stack = stack(this.stack);
    this.stacks.push(getCurrentStack() || this.stack);
    setCurrentStack(this.stack);
    return this.stack;
  }
  removeStack() {
    const lastStack = this.stack;
    this.stack = lastStack.parent;
    setCurrentStack(this.stacks.pop());
    return lastStack;
  }
  getDataFromNode(node, shaderStage = this.shaderStage) {
    const cache2 = node.isGlobal(this) ? this.globalCache : this.cache;
    let nodeData = cache2.getNodeData(node);
    if (nodeData === void 0) {
      nodeData = {};
      cache2.setNodeData(node, nodeData);
    }
    if (nodeData[shaderStage] === void 0)
      nodeData[shaderStage] = {};
    return nodeData[shaderStage];
  }
  getNodeProperties(node, shaderStage = "any") {
    const nodeData = this.getDataFromNode(node, shaderStage);
    return nodeData.properties || (nodeData.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(node, type) {
    const nodeData = this.getDataFromNode(node);
    let bufferAttribute2 = nodeData.bufferAttribute;
    if (bufferAttribute2 === void 0) {
      const index = this.uniforms.index++;
      bufferAttribute2 = new NodeAttribute_default("nodeAttribute" + index, type, node);
      this.bufferAttributes.push(bufferAttribute2);
      nodeData.bufferAttribute = bufferAttribute2;
    }
    return bufferAttribute2;
  }
  getStructTypeFromNode(node, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    if (nodeData.structType === void 0) {
      const index = this.structs.index++;
      node.name = `StructType${index}`;
      this.structs[shaderStage].push(node);
      nodeData.structType = node;
    }
    return node;
  }
  getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeUniform = nodeData.uniform;
    if (nodeUniform === void 0) {
      const index = this.uniforms.index++;
      nodeUniform = new NodeUniform_default(name || "nodeUniform" + index, type, node);
      this.uniforms[shaderStage].push(nodeUniform);
      nodeData.uniform = nodeUniform;
    }
    return nodeUniform;
  }
  getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeVar = nodeData.variable;
    if (nodeVar === void 0) {
      const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);
      if (name === null)
        name = "nodeVar" + vars.length;
      nodeVar = new NodeVar_default(name, type);
      vars.push(nodeVar);
      nodeData.variable = nodeVar;
    }
    return nodeVar;
  }
  getVaryingFromNode(node, name = null, type = node.getNodeType(this)) {
    const nodeData = this.getDataFromNode(node, "any");
    let nodeVarying = nodeData.varying;
    if (nodeVarying === void 0) {
      const varyings = this.varyings;
      const index = varyings.length;
      if (name === null)
        name = "nodeVarying" + index;
      nodeVarying = new NodeVarying_default(name, type);
      varyings.push(nodeVarying);
      nodeData.varying = nodeVarying;
    }
    return nodeVarying;
  }
  getCodeFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node);
    let nodeCode = nodeData.code;
    if (nodeCode === void 0) {
      const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);
      const index = codes.length;
      nodeCode = new NodeCode_default("nodeCode" + index, type);
      codes.push(nodeCode);
      nodeData.code = nodeCode;
    }
    return nodeCode;
  }
  addLineFlowCode(code2) {
    if (code2 === "")
      return this;
    code2 = this.tab + code2;
    if (!/;\s*$/.test(code2)) {
      code2 = code2 + ";\n";
    }
    this.flow.code += code2;
    return this;
  }
  addFlowCode(code2) {
    this.flow.code += code2;
    return this;
  }
  addFlowTab() {
    this.tab += "	";
    return this;
  }
  removeFlowTab() {
    this.tab = this.tab.slice(0, -1);
    return this;
  }
  getFlowData(node) {
    return this.flowsData.get(node);
  }
  flowNode(node) {
    const output2 = node.getNodeType(this);
    const flowData = this.flowChildNode(node, output2);
    this.flowsData.set(node, flowData);
    return flowData;
  }
  flowShaderNode(shaderNode) {
    const layout = shaderNode.layout;
    let inputs;
    if (shaderNode.isArrayInput) {
      inputs = [];
      for (const input of layout.inputs) {
        inputs.push(new ParameterNode_default(input.type, input.name));
      }
    } else {
      inputs = {};
      for (const input of layout.inputs) {
        inputs[input.name] = new ParameterNode_default(input.type, input.name);
      }
    }
    shaderNode.layout = null;
    const callNode = shaderNode.call(inputs);
    const flowData = this.flowStagesNode(callNode, layout.type);
    shaderNode.layout = layout;
    return flowData;
  }
  flowStagesNode(node, output2 = null) {
    const previousFlow = this.flow;
    const previousVars = this.vars;
    const previousBuildStage = this.buildStage;
    const flow = {
      code: ""
    };
    this.flow = flow;
    this.vars = {};
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      flow.result = node.build(this, output2);
    }
    flow.vars = this.getVars(this.shaderStage);
    this.flow = previousFlow;
    this.vars = previousVars;
    this.setBuildStage(previousBuildStage);
    return flow;
  }
  flowChildNode(node, output2 = null) {
    const previousFlow = this.flow;
    const flow = {
      code: ""
    };
    this.flow = flow;
    flow.result = node.build(this, output2);
    this.flow = previousFlow;
    return flow;
  }
  flowNodeFromShaderStage(shaderStage, node, output2 = null, propertyName = null) {
    const previousShaderStage = this.shaderStage;
    this.setShaderStage(shaderStage);
    const flowData = this.flowChildNode(node, output2);
    if (propertyName !== null) {
      flowData.code += `${this.tab + propertyName} = ${flowData.result};
`;
    }
    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
    this.setShaderStage(previousShaderStage);
    return flowData;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(type, name) {
    return `${this.getType(type)} ${name}`;
  }
  getVars(shaderStage) {
    let snippet = "";
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippet += `${this.getVar(variable.type, variable.name)}; `;
      }
    }
    return snippet;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(shaderStage) {
    const codes = this.codes[shaderStage];
    let code2 = "";
    if (codes !== void 0) {
      for (const nodeCode of codes) {
        code2 += nodeCode.code + "\n";
      }
    }
    return code2;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(shaderStage) {
    this.shaderStage = shaderStage;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(buildStage) {
    this.buildStage = buildStage;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      if (this.context.vertex && this.context.vertex.isNode) {
        this.flowNodeFromShaderStage("vertex", this.context.vertex);
      }
      for (const shaderStage of shaderStages) {
        this.setShaderStage(shaderStage);
        const flowNodes = this.flowNodes[shaderStage];
        for (const node of flowNodes) {
          if (buildStage === "generate") {
            this.flowNode(node);
          } else {
            node.build(this);
          }
        }
      }
    }
    this.setBuildStage(null);
    this.setShaderStage(null);
    this.buildCode();
    this.buildUpdateNodes();
    return this;
  }
  getNodeUniform(uniformNode, type) {
    if (type === "float")
      return new FloatNodeUniform(uniformNode);
    if (type === "vec2")
      return new Vector2NodeUniform(uniformNode);
    if (type === "vec3")
      return new Vector3NodeUniform(uniformNode);
    if (type === "vec4")
      return new Vector4NodeUniform(uniformNode);
    if (type === "color")
      return new ColorNodeUniform(uniformNode);
    if (type === "mat3")
      return new Matrix3NodeUniform(uniformNode);
    if (type === "mat4")
      return new Matrix4NodeUniform(uniformNode);
    throw new Error(`Uniform "${type}" not declared.`);
  }
  createNodeMaterial(type) {
    return createNodeMaterialFromType(type);
  }
  getPrimitiveType(type) {
    let primitiveType;
    if (type[0] === "i")
      primitiveType = "int";
    else if (type[0] === "u")
      primitiveType = "uint";
    else
      primitiveType = "float";
    return primitiveType;
  }
  format(snippet, fromType, toType) {
    fromType = this.getVectorType(fromType);
    toType = this.getVectorType(toType);
    if (fromType === toType || toType === null || this.isReference(toType)) {
      return snippet;
    }
    const fromTypeLength = this.getTypeLength(fromType);
    const toTypeLength = this.getTypeLength(toType);
    if (fromTypeLength > 4) {
      return snippet;
    }
    if (toTypeLength > 4 || toTypeLength === 0) {
      return snippet;
    }
    if (fromTypeLength === toTypeLength) {
      return `${this.getType(toType)}( ${snippet} )`;
    }
    if (fromTypeLength > toTypeLength) {
      return this.format(`${snippet}.${"xyz".slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);
    }
    if (toTypeLength === 4 && fromTypeLength > 1) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec3")}, 1.0 )`;
    }
    if (fromTypeLength === 2) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec2")}, 0.0 )`;
    }
    if (fromTypeLength === 1 && toTypeLength > 1 && fromType[0] !== toType[0]) {
      snippet = `${this.getType(this.getPrimitiveType(toType))}( ${snippet} )`;
    }
    return `${this.getType(toType)}( ${snippet} )`;
  }
  getSignature() {
    return `// Three.js r${REVISION} - NodeMaterial System
`;
  }
};
var NodeBuilder_default = NodeBuilder;

// node_modules/three/examples/jsm/nodes/core/NodeFrame.js
var NodeFrame = class {
  constructor() {
    this.time = 0;
    this.deltaTime = 0;
    this.frameId = 0;
    this.renderId = 0;
    this.startTime = null;
    this.updateMap = /* @__PURE__ */ new WeakMap();
    this.updateBeforeMap = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.material = null;
    this.camera = null;
    this.object = null;
    this.scene = null;
  }
  _getMaps(referenceMap, nodeRef) {
    let maps = referenceMap.get(nodeRef);
    if (maps === void 0) {
      maps = {
        renderMap: /* @__PURE__ */ new WeakMap(),
        frameMap: /* @__PURE__ */ new WeakMap()
      };
      referenceMap.set(nodeRef, maps);
    }
    return maps;
  }
  updateBeforeNode(node) {
    const updateType = node.getUpdateBeforeType();
    const reference2 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const { frameMap } = this._getMaps(this.updateBeforeMap, reference2);
      if (frameMap.get(node) !== this.frameId) {
        frameMap.set(node, this.frameId);
        node.updateBefore(this);
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const { renderMap } = this._getMaps(this.updateBeforeMap, reference2);
      if (renderMap.get(node) !== this.renderId) {
        renderMap.set(node, this.renderId);
        node.updateBefore(this);
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.updateBefore(this);
    }
  }
  updateNode(node) {
    const updateType = node.getUpdateType();
    const reference2 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const { frameMap } = this._getMaps(this.updateMap, reference2);
      if (frameMap.get(node) !== this.frameId) {
        frameMap.set(node, this.frameId);
        node.update(this);
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const { renderMap } = this._getMaps(this.updateMap, reference2);
      if (renderMap.get(node) !== this.renderId) {
        renderMap.set(node, this.renderId);
        node.update(this);
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.update(this);
    }
  }
  update() {
    this.frameId++;
    if (this.lastTime === void 0)
      this.lastTime = performance.now();
    this.deltaTime = (performance.now() - this.lastTime) / 1e3;
    this.lastTime = performance.now();
    this.time += this.deltaTime;
  }
};
var NodeFrame_default = NodeFrame;

// node_modules/three/examples/jsm/nodes/core/NodeFunctionInput.js
var NodeFunctionInput = class {
  constructor(type, name, count = null, qualifier = "", isConst = false) {
    this.type = type;
    this.name = name;
    this.count = count;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;
var NodeFunctionInput_default = NodeFunctionInput;

// node_modules/three/examples/jsm/nodes/core/StructTypeNode.js
var StructTypeNode = class extends Node_default {
  constructor(types) {
    super();
    this.types = types;
    this.isStructTypeNode = true;
  }
  getMemberTypes() {
    return this.types;
  }
};
var StructTypeNode_default = StructTypeNode;
addNodeClass("StructTypeNode", StructTypeNode);

// node_modules/three/examples/jsm/nodes/core/OutputStructNode.js
var OutputStructNode = class extends Node_default {
  constructor(...members) {
    super();
    this.isOutputStructNode = true;
    this.members = members;
  }
  setup(builder) {
    super.setup(builder);
    const members = this.members;
    const types = [];
    for (let i = 0; i < members.length; i++) {
      types.push(members[i].getNodeType(builder));
    }
    this.nodeType = builder.getStructTypeFromNode(new StructTypeNode_default(types)).name;
  }
  generate(builder, output2) {
    const nodeVar = builder.getVarFromNode(this);
    nodeVar.isOutputStructVar = true;
    const propertyName = builder.getPropertyName(nodeVar);
    const members = this.members;
    const structPrefix = propertyName !== "" ? propertyName + "." : "";
    for (let i = 0; i < members.length; i++) {
      const snippet = members[i].build(builder, output2);
      builder.addLineFlowCode(`${structPrefix}m${i} = ${snippet}`);
    }
    return propertyName;
  }
};
var OutputStructNode_default = OutputStructNode;
var outputStruct = nodeProxy(OutputStructNode);
addNodeClass("OutputStructNode", OutputStructNode);

// node_modules/three/examples/jsm/nodes/math/HashNode.js
var HashNode = class extends Node_default {
  constructor(seedNode) {
    super();
    this.seedNode = seedNode;
  }
  setup() {
    const state = this.seedNode.uint().mul(747796405).add(2891336453);
    const word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);
    const result = word.shiftRight(22).bitXor(word);
    return result.float().mul(1 / 2 ** 32);
  }
};
var HashNode_default = HashNode;
var hash = nodeProxy(HashNode);
addNodeElement("hash", hash);
addNodeClass("HashNode", HashNode);

// node_modules/three/examples/jsm/nodes/utils/DiscardNode.js
var discardExpression;
var DiscardNode = class extends CondNode_default {
  constructor(condNode) {
    discardExpression = discardExpression || expression("discard");
    super(condNode, discardExpression);
  }
};
var DiscardNode_default = DiscardNode;
var inlineDiscard = nodeProxy(DiscardNode);
var discard = (condNode) => inlineDiscard(condNode).append();
addNodeElement("discard", discard);
addNodeClass("DiscardNode", DiscardNode);

// node_modules/three/examples/jsm/nodes/utils/LoopNode.js
var LoopNode = class extends Node_default {
  constructor(params = []) {
    super();
    this.params = params;
  }
  getVarName(index) {
    return String.fromCharCode("i".charCodeAt() + index);
  }
  getProperties(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.stackNode !== void 0)
      return properties;
    const inputs = {};
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      const param = this.params[i];
      const name = param.isNode !== true && param.name || this.getVarName(i);
      const type = param.isNode !== true && param.type || "int";
      inputs[name] = expression(name, type);
    }
    properties.returnsNode = this.params[this.params.length - 1](inputs, builder.addStack(), builder);
    properties.stackNode = builder.removeStack();
    return properties;
  }
  getNodeType(builder) {
    const { returnsNode } = this.getProperties(builder);
    return returnsNode ? returnsNode.getNodeType(builder) : "void";
  }
  setup(builder) {
    this.getProperties(builder);
  }
  generate(builder) {
    const properties = this.getProperties(builder);
    const contextData = { tempWrite: false };
    const params = this.params;
    const stackNode = properties.stackNode;
    for (let i = 0, l = params.length - 1; i < l; i++) {
      const param = params[i];
      let start = null, end = null, name = null, type = null, condition = null, update = null;
      if (param.isNode) {
        type = "int";
        name = this.getVarName(i);
        start = "0";
        end = param.build(builder, type);
        condition = "<";
      } else {
        type = param.type || "int";
        name = param.name || this.getVarName(i);
        start = param.start;
        end = param.end;
        condition = param.condition;
        update = param.update;
        if (typeof start === "number")
          start = start.toString();
        else if (start && start.isNode)
          start = start.build(builder, type);
        if (typeof end === "number")
          end = end.toString();
        else if (end && end.isNode)
          end = end.build(builder, type);
        if (start !== void 0 && end === void 0) {
          start = start + " - 1";
          end = "0";
          condition = ">=";
        } else if (end !== void 0 && start === void 0) {
          start = "0";
          condition = "<";
        }
        if (condition === void 0) {
          if (Number(start) > Number(end)) {
            condition = ">=";
          } else {
            condition = "<";
          }
        }
      }
      const internalParam = { start, end, condition };
      const startSnippet = internalParam.start;
      const endSnippet = internalParam.end;
      let declarationSnippet = "";
      let conditionalSnippet = "";
      let updateSnippet = "";
      if (!update) {
        if (type === "int") {
          if (condition.includes("<"))
            update = "++";
          else
            update = "--";
        } else {
          if (condition.includes("<"))
            update = "+= 1";
          else
            update = "-= 1";
        }
      }
      declarationSnippet += builder.getVar(type, name) + " = " + startSnippet;
      conditionalSnippet += name + " " + condition + " " + endSnippet;
      updateSnippet += name + " " + update;
      const forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
      builder.addFlowCode((i === 0 ? "\n" : "") + builder.tab + forSnippet + " {\n\n").addFlowTab();
    }
    const stackSnippet = context(stackNode, contextData).build(builder, "void");
    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : "";
    builder.removeFlowTab().addFlowCode("\n" + builder.tab + stackSnippet);
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      builder.addFlowCode((i === 0 ? "" : builder.tab) + "}\n\n").removeFlowTab();
    }
    builder.addFlowTab();
    return returnsSnippet;
  }
};
var LoopNode_default = LoopNode;
var loop = (...params) => nodeObject(new LoopNode(nodeArray(params, "int"))).append();
addNodeElement("loop", (returns, ...params) => bypass(returns, loop(...params)));
addNodeClass("LoopNode", LoopNode);

// node_modules/three/examples/jsm/nodes/utils/MatcapUVNode.js
var MatcapUVNode = class extends TempNode_default {
  constructor() {
    super("vec2");
  }
  setup() {
    const x = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();
    const y = positionViewDirection.cross(x);
    return vec2(x.dot(transformedNormalView), y.dot(transformedNormalView)).mul(0.495).add(0.5);
  }
};
var MatcapUVNode_default = MatcapUVNode;
var matcapUV = nodeImmutable(MatcapUVNode);
addNodeClass("MatcapUVNode", MatcapUVNode);

// node_modules/three/examples/jsm/nodes/utils/TimerNode.js
var TimerNode = class _TimerNode extends UniformNode_default {
  constructor(scope = _TimerNode.LOCAL, scale = 1, value = 0) {
    super(value);
    this.scope = scope;
    this.scale = scale;
    this.updateType = NodeUpdateType.FRAME;
  }
  /*
  	@TODO:
  	getNodeType( builder ) {
  
  		const scope = this.scope;
  
  		if ( scope === TimerNode.FRAME ) {
  
  			return 'uint';
  
  		}
  
  		return 'float';
  
  	}
  */
  update(frame) {
    const scope = this.scope;
    const scale = this.scale;
    if (scope === _TimerNode.LOCAL) {
      this.value += frame.deltaTime * scale;
    } else if (scope === _TimerNode.DELTA) {
      this.value = frame.deltaTime * scale;
    } else if (scope === _TimerNode.FRAME) {
      this.value = frame.frameId;
    } else {
      this.value = frame.time * scale;
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
    data.scale = this.scale;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
    this.scale = data.scale;
  }
};
TimerNode.LOCAL = "local";
TimerNode.GLOBAL = "global";
TimerNode.DELTA = "delta";
TimerNode.FRAME = "frame";
var TimerNode_default = TimerNode;
var timerLocal = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.LOCAL, timeScale, value));
var timerGlobal = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.GLOBAL, timeScale, value));
var timerDelta = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.DELTA, timeScale, value));
var frameId = nodeImmutable(TimerNode, TimerNode.FRAME).uint();
addNodeClass("TimerNode", TimerNode);

// node_modules/three/examples/jsm/nodes/utils/OscNode.js
var OscNode = class _OscNode extends Node_default {
  constructor(method = _OscNode.SINE, timeNode = timerLocal()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  setup() {
    const method = this.method;
    const timeNode = nodeObject(this.timeNode);
    let outputNode = null;
    if (method === _OscNode.SINE) {
      outputNode = timeNode.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);
    } else if (method === _OscNode.SQUARE) {
      outputNode = timeNode.fract().round();
    } else if (method === _OscNode.TRIANGLE) {
      outputNode = timeNode.add(0.5).fract().mul(2).sub(1).abs();
    } else if (method === _OscNode.SAWTOOTH) {
      outputNode = timeNode.fract();
    }
    return outputNode;
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
OscNode.SINE = "sine";
OscNode.SQUARE = "square";
OscNode.TRIANGLE = "triangle";
OscNode.SAWTOOTH = "sawtooth";
var OscNode_default = OscNode;
var oscSine = nodeProxy(OscNode, OscNode.SINE);
var oscSquare = nodeProxy(OscNode, OscNode.SQUARE);
var oscTriangle = nodeProxy(OscNode, OscNode.TRIANGLE);
var oscSawtooth = nodeProxy(OscNode, OscNode.SAWTOOTH);
addNodeClass("OscNode", OscNode);

// node_modules/three/examples/jsm/nodes/utils/PackingNode.js
var PackingNode = class _PackingNode extends TempNode_default {
  constructor(scope, node) {
    super();
    this.scope = scope;
    this.node = node;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  setup() {
    const { scope, node } = this;
    let result = null;
    if (scope === _PackingNode.DIRECTION_TO_COLOR) {
      result = node.mul(0.5).add(0.5);
    } else if (scope === _PackingNode.COLOR_TO_DIRECTION) {
      result = node.mul(2).sub(1);
    }
    return result;
  }
};
PackingNode.DIRECTION_TO_COLOR = "directionToColor";
PackingNode.COLOR_TO_DIRECTION = "colorToDirection";
var PackingNode_default = PackingNode;
var directionToColor = nodeProxy(PackingNode, PackingNode.DIRECTION_TO_COLOR);
var colorToDirection = nodeProxy(PackingNode, PackingNode.COLOR_TO_DIRECTION);
addNodeElement("directionToColor", directionToColor);
addNodeElement("colorToDirection", colorToDirection);
addNodeClass("PackingNode", PackingNode);

// node_modules/three/examples/jsm/nodes/utils/RemapNode.js
var RemapNode = class extends Node_default {
  constructor(node, inLowNode, inHighNode, outLowNode, outHighNode) {
    super();
    this.node = node;
    this.inLowNode = inLowNode;
    this.inHighNode = inHighNode;
    this.outLowNode = outLowNode;
    this.outHighNode = outHighNode;
    this.doClamp = true;
  }
  setup() {
    const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
    let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
    if (doClamp === true)
      t = t.clamp();
    return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);
  }
};
var RemapNode_default = RemapNode;
var remap = nodeProxy(RemapNode, null, null, { doClamp: false });
var remapClamp = nodeProxy(RemapNode);
addNodeElement("remap", remap);
addNodeElement("remapClamp", remapClamp);
addNodeClass("RemapNode", RemapNode);

// node_modules/three/examples/jsm/nodes/utils/RotateUVNode.js
var RotateUVNode = class extends TempNode_default {
  constructor(uvNode, rotationNode, centerNode = vec2(0.5)) {
    super("vec2");
    this.uvNode = uvNode;
    this.rotationNode = rotationNode;
    this.centerNode = centerNode;
  }
  setup() {
    const { uvNode, rotationNode, centerNode } = this;
    const cosAngle = rotationNode.cos();
    const sinAngle = rotationNode.sin();
    const vector = uvNode.sub(centerNode);
    const rotatedVector = vec2(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( vector )?
      vec2(cosAngle, sinAngle).dot(vector),
      vec2(sinAngle.negate(), cosAngle).dot(vector)
    );
    return rotatedVector.add(centerNode);
  }
};
var RotateUVNode_default = RotateUVNode;
var rotateUV = nodeProxy(RotateUVNode);
addNodeElement("rotateUV", rotateUV);
addNodeClass("RotateUVNode", RotateUVNode);

// node_modules/three/examples/jsm/nodes/utils/SpriteSheetUVNode.js
var SpriteSheetUVNode = class extends Node_default {
  constructor(countNode, uvNode = uv(), frameNode = float(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  setup() {
    const { frameNode, uvNode, countNode } = this;
    const { width, height } = countNode;
    const frameNum = frameNode.mod(width.mul(height)).floor();
    const column = frameNum.mod(width);
    const row = height.sub(frameNum.add(1).div(width).ceil());
    const scale = countNode.reciprocal();
    const uvFrameOffset = vec2(column, row);
    return uvNode.add(uvFrameOffset).mul(scale);
  }
};
var SpriteSheetUVNode_default = SpriteSheetUVNode;
var spritesheetUV = nodeProxy(SpriteSheetUVNode);
addNodeClass("SpriteSheetUVNode", SpriteSheetUVNode);

// node_modules/three/examples/jsm/nodes/utils/TriplanarTexturesNode.js
var TriplanarTexturesNode = class extends Node_default {
  constructor(textureXNode, textureYNode = null, textureZNode = null, scaleNode = float(1), positionNode = positionWorld, normalNode = normalWorld) {
    super("vec4");
    this.textureXNode = textureXNode;
    this.textureYNode = textureYNode;
    this.textureZNode = textureZNode;
    this.scaleNode = scaleNode;
    this.positionNode = positionNode;
    this.normalNode = normalNode;
  }
  setup() {
    const { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;
    let bf = normalNode.abs().normalize();
    bf = bf.div(bf.dot(vec3(1)));
    const tx = positionNode.yz.mul(scaleNode);
    const ty = positionNode.zx.mul(scaleNode);
    const tz = positionNode.xy.mul(scaleNode);
    const textureX = textureXNode.value;
    const textureY = textureYNode !== null ? textureYNode.value : textureX;
    const textureZ = textureZNode !== null ? textureZNode.value : textureX;
    const cx = texture(textureX, tx).mul(bf.x);
    const cy = texture(textureY, ty).mul(bf.y);
    const cz = texture(textureZ, tz).mul(bf.z);
    return add(cx, cy, cz);
  }
};
var TriplanarTexturesNode_default = TriplanarTexturesNode;
var triplanarTextures = nodeProxy(TriplanarTexturesNode);
var triplanarTexture = (...params) => triplanarTextures(...params);
addNodeElement("triplanarTexture", triplanarTexture);
addNodeClass("TriplanarTexturesNode", TriplanarTexturesNode);

// node_modules/three/examples/jsm/nodes/accessors/BitangentNode.js
var BitangentNode = class _BitangentNode extends Node_default {
  constructor(scope = _BitangentNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `bitangent-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let crossNormalTangent;
    if (scope === _BitangentNode.GEOMETRY) {
      crossNormalTangent = normalGeometry.cross(tangentGeometry);
    } else if (scope === _BitangentNode.LOCAL) {
      crossNormalTangent = normalLocal.cross(tangentLocal);
    } else if (scope === _BitangentNode.VIEW) {
      crossNormalTangent = normalView.cross(tangentView);
    } else if (scope === _BitangentNode.WORLD) {
      crossNormalTangent = normalWorld.cross(tangentWorld);
    }
    const vertexNode = crossNormalTangent.mul(tangentGeometry.w).xyz;
    const outputNode = normalize(varying(vertexNode));
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
BitangentNode.GEOMETRY = "geometry";
BitangentNode.LOCAL = "local";
BitangentNode.VIEW = "view";
BitangentNode.WORLD = "world";
var BitangentNode_default = BitangentNode;
var bitangentGeometry = nodeImmutable(BitangentNode, BitangentNode.GEOMETRY);
var bitangentLocal = nodeImmutable(BitangentNode, BitangentNode.LOCAL);
var bitangentView = nodeImmutable(BitangentNode, BitangentNode.VIEW);
var bitangentWorld = nodeImmutable(BitangentNode, BitangentNode.WORLD);
var transformedBitangentView = normalize(transformedNormalView.cross(transformedTangentView).mul(tangentGeometry.w));
var transformedBitangentWorld = normalize(transformedBitangentView.transformDirection(cameraViewMatrix));
addNodeClass("BitangentNode", BitangentNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureBicubicNode.js
var bC = 1 / 6;
var w0 = (a) => mul(bC, mul(a, mul(a, a.negate().add(3)).sub(3)).add(1));
var w1 = (a) => mul(bC, mul(a, mul(a, mul(3, a).sub(6))).add(4));
var w2 = (a) => mul(bC, mul(a, mul(a, mul(-3, a).add(3)).add(3)).add(1));
var w3 = (a) => mul(bC, pow(a, 3));
var g0 = (a) => w0(a).add(w1(a));
var g1 = (a) => w2(a).add(w3(a));
var h0 = (a) => add(-1, w1(a).div(w0(a).add(w1(a))));
var h1 = (a) => add(1, w3(a).div(w2(a).add(w3(a))));
var bicubic = (textureNode, texelSize, lod) => {
  const uv2 = textureNode.uvNode;
  const uvScaled = mul(uv2, texelSize.zw).add(0.5);
  const iuv = floor(uvScaled);
  const fuv = fract(uvScaled);
  const g0x = g0(fuv.x);
  const g1x = g1(fuv.x);
  const h0x = h0(fuv.x);
  const h1x = h1(fuv.x);
  const h0y = h0(fuv.y);
  const h1y = h1(fuv.y);
  const p0 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p2 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const a = g0(fuv.y).mul(add(g0x.mul(textureNode.uv(p0).level(lod)), g1x.mul(textureNode.uv(p1).level(lod))));
  const b = g1(fuv.y).mul(add(g0x.mul(textureNode.uv(p2).level(lod)), g1x.mul(textureNode.uv(p3).level(lod))));
  return a.add(b);
};
var textureBicubicMethod = (textureNode, lodNode) => {
  const fLodSize = vec2(textureNode.size(int(lodNode)));
  const cLodSize = vec2(textureNode.size(int(lodNode.add(1))));
  const fLodSizeInv = div(1, fLodSize);
  const cLodSizeInv = div(1, cLodSize);
  const fSample = bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));
  const cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil(lodNode));
  return fract(lodNode).mix(fSample, cSample);
};
var TextureBicubicNode = class extends TempNode_default {
  constructor(textureNode, blurNode = float(3)) {
    super("vec4");
    this.textureNode = textureNode;
    this.blurNode = blurNode;
  }
  setup() {
    return textureBicubicMethod(this.textureNode, this.blurNode);
  }
};
var TextureBicubicNode_default = TextureBicubicNode;
var textureBicubic = nodeProxy(TextureBicubicNode);
addNodeElement("bicubic", textureBicubic);
addNodeClass("TextureBicubicNode", TextureBicubicNode);

// node_modules/three/examples/jsm/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
var PointUVNode_default = PointUVNode;
var pointUV = nodeImmutable(PointUVNode);
addNodeClass("PointUVNode", PointUVNode);

// node_modules/three/examples/jsm/nodes/accessors/SceneNode.js
var SceneNode = class _SceneNode extends Node_default {
  constructor(scope = _SceneNode.BACKGROUND_BLURRINESS, scene = null) {
    super();
    this.scope = scope;
    this.scene = scene;
  }
  setup(builder) {
    const scope = this.scope;
    const scene = this.scene !== null ? this.scene : builder.scene;
    let output2;
    if (scope === _SceneNode.BACKGROUND_BLURRINESS) {
      output2 = reference("backgroundBlurriness", "float", scene);
    } else if (scope === _SceneNode.BACKGROUND_INTENSITY) {
      output2 = reference("backgroundIntensity", "float", scene);
    } else {
      console.error("THREE.SceneNode: Unknown scope:", scope);
    }
    return output2;
  }
};
SceneNode.BACKGROUND_BLURRINESS = "backgroundBlurriness";
SceneNode.BACKGROUND_INTENSITY = "backgroundIntensity";
var SceneNode_default = SceneNode;
var backgroundBlurriness = nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);
var backgroundIntensity = nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);
addNodeClass("SceneNode", SceneNode);

// node_modules/three/examples/jsm/nodes/accessors/StorageBufferNode.js
var StorageBufferNode = class extends BufferNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType, bufferCount);
    this.isStorageBufferNode = true;
  }
  getInputType() {
    return "storageBuffer";
  }
};
var StorageBufferNode_default = StorageBufferNode;
var storage = (value, type, count) => nodeObject(new StorageBufferNode(value, type, count));
addNodeClass("StorageBufferNode", StorageBufferNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureStoreNode.js
var TextureStoreNode = class extends TextureNode_default {
  constructor(value, uvNode, storeNode = null) {
    super(value, uvNode);
    this.storeNode = storeNode;
    this.isStoreTextureNode = true;
  }
  getNodeType() {
    return "void";
  }
};
var TextureStoreNode_default = TextureStoreNode;
var textureStore = nodeProxy(TextureStoreNode);
addNodeClass("TextureStoreNode", TextureStoreNode);

// node_modules/three/examples/jsm/nodes/accessors/UserDataNode.js
var UserDataNode = class extends ReferenceNode_default {
  constructor(property2, inputType, userData2 = null) {
    super(property2, inputType, userData2);
    this.userData = userData2;
  }
  update(frame) {
    this.reference = this.userData !== null ? this.userData : frame.object.userData;
    super.update(frame);
  }
};
var UserDataNode_default = UserDataNode;
var userData = (name, inputType, userData2) => nodeObject(new UserDataNode(name, inputType, userData2));
addNodeClass("UserDataNode", UserDataNode);

// node_modules/three/examples/jsm/nodes/display/BlendModeNode.js
var BurnNode = tslFn(({ base, blend }) => {
  const fn = (c) => blend[c].lessThan(EPSILON).cond(blend[c], base[c].oneMinus().div(blend[c]).oneMinus().max(0));
  return vec3(fn("x"), fn("y"), fn("z"));
});
var DodgeNode = tslFn(({ base, blend }) => {
  const fn = (c) => blend[c].equal(1).cond(blend[c], base[c].div(blend[c].oneMinus()).max(0));
  return vec3(fn("x"), fn("y"), fn("z"));
});
var ScreenNode = tslFn(({ base, blend }) => {
  const fn = (c) => base[c].oneMinus().mul(blend[c].oneMinus()).oneMinus();
  return vec3(fn("x"), fn("y"), fn("z"));
});
var OverlayNode = tslFn(({ base, blend }) => {
  const fn = (c) => base[c].lessThan(0.5).cond(base[c].mul(blend[c], 2), base[c].oneMinus().mul(blend[c].oneMinus()).oneMinus());
  return vec3(fn("x"), fn("y"), fn("z"));
});
var BlendModeNode = class _BlendModeNode extends TempNode_default {
  constructor(blendMode, baseNode, blendNode) {
    super();
    this.blendMode = blendMode;
    this.baseNode = baseNode;
    this.blendNode = blendNode;
  }
  setup() {
    const { blendMode, baseNode, blendNode } = this;
    const params = { base: baseNode, blend: blendNode };
    let outputNode = null;
    if (blendMode === _BlendModeNode.BURN) {
      outputNode = BurnNode(params);
    } else if (blendMode === _BlendModeNode.DODGE) {
      outputNode = DodgeNode(params);
    } else if (blendMode === _BlendModeNode.SCREEN) {
      outputNode = ScreenNode(params);
    } else if (blendMode === _BlendModeNode.OVERLAY) {
      outputNode = OverlayNode(params);
    }
    return outputNode;
  }
};
BlendModeNode.BURN = "burn";
BlendModeNode.DODGE = "dodge";
BlendModeNode.SCREEN = "screen";
BlendModeNode.OVERLAY = "overlay";
var BlendModeNode_default = BlendModeNode;
var burn = nodeProxy(BlendModeNode, BlendModeNode.BURN);
var dodge = nodeProxy(BlendModeNode, BlendModeNode.DODGE);
var overlay = nodeProxy(BlendModeNode, BlendModeNode.OVERLAY);
var screen = nodeProxy(BlendModeNode, BlendModeNode.SCREEN);
addNodeElement("burn", burn);
addNodeElement("dodge", dodge);
addNodeElement("overlay", overlay);
addNodeElement("screen", screen);
addNodeClass("BlendModeNode", BlendModeNode);

// node_modules/three/examples/jsm/nodes/display/FrontFacingNode.js
var FrontFacingNode = class extends Node_default {
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    return builder.getFrontFacing();
  }
};
var FrontFacingNode_default = FrontFacingNode;
var frontFacing = nodeImmutable(FrontFacingNode);
var faceDirection = float(frontFacing).mul(2).sub(1);
addNodeClass("FrontFacingNode", FrontFacingNode);

// node_modules/three/examples/jsm/nodes/display/BumpMapNode.js
var dHdxy_fwd = tslFn(({ textureNode, bumpScale }) => {
  let texNode = textureNode;
  if (texNode.isTextureNode !== true) {
    texNode.traverse((node) => {
      if (node.isTextureNode === true)
        texNode = node;
    });
  }
  if (texNode.isTextureNode !== true) {
    throw new Error("THREE.TSL: dHdxy_fwd() requires a TextureNode.");
  }
  const Hll = float(textureNode);
  const uvNode = texNode.uvNode || uv();
  const sampleTexture = (uv2) => textureNode.cache().context({ getUV: () => uv2, forceUVContext: true });
  return vec2(
    float(sampleTexture(uvNode.add(uvNode.dFdx()))).sub(Hll),
    float(sampleTexture(uvNode.add(uvNode.dFdy()))).sub(Hll)
  ).mul(bumpScale);
});
var perturbNormalArb = tslFn((inputs) => {
  const { surf_pos, surf_norm, dHdxy } = inputs;
  const vSigmaX = surf_pos.dFdx().normalize();
  const vSigmaY = surf_pos.dFdy().normalize();
  const vN = surf_norm;
  const R1 = vSigmaY.cross(vN);
  const R2 = vN.cross(vSigmaX);
  const fDet = vSigmaX.dot(R1).mul(faceDirection);
  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));
  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();
});
var BumpMapNode = class extends TempNode_default {
  constructor(textureNode, scaleNode = null) {
    super("vec3");
    this.textureNode = textureNode;
    this.scaleNode = scaleNode;
  }
  setup() {
    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
    const dHdxy = dHdxy_fwd({ textureNode: this.textureNode, bumpScale });
    return perturbNormalArb({
      surf_pos: positionView,
      surf_norm: normalView,
      dHdxy
    });
  }
};
var BumpMapNode_default = BumpMapNode;
var bumpMap = nodeProxy(BumpMapNode);
addNodeElement("bumpMap", bumpMap);
addNodeClass("BumpMapNode", BumpMapNode);

// node_modules/three/examples/jsm/nodes/display/ColorAdjustmentNode.js
var saturationNode = tslFn(({ color: color2, adjustment }) => {
  return adjustment.mix(luminance(color2), color2);
});
var vibranceNode = tslFn(({ color: color2, adjustment }) => {
  const average = add(color2.r, color2.g, color2.b).div(3);
  const mx = color2.r.max(color2.g.max(color2.b));
  const amt = mx.sub(average).mul(adjustment).mul(-3);
  return mix(color2, mx, amt);
});
var hueNode = tslFn(({ color: color2, adjustment }) => {
  const k = vec3(0.57735, 0.57735, 0.57735);
  const cosAngle = adjustment.cos();
  return vec3(color2.rgb.mul(cosAngle).add(k.cross(color2.rgb).mul(adjustment.sin()).add(k.mul(dot(k, color2.rgb).mul(cosAngle.oneMinus())))));
});
var ColorAdjustmentNode = class _ColorAdjustmentNode extends TempNode_default {
  constructor(method, colorNode, adjustmentNode = float(1)) {
    super("vec3");
    this.method = method;
    this.colorNode = colorNode;
    this.adjustmentNode = adjustmentNode;
  }
  setup() {
    const { method, colorNode, adjustmentNode } = this;
    const callParams = { color: colorNode, adjustment: adjustmentNode };
    let outputNode = null;
    if (method === _ColorAdjustmentNode.SATURATION) {
      outputNode = saturationNode(callParams);
    } else if (method === _ColorAdjustmentNode.VIBRANCE) {
      outputNode = vibranceNode(callParams);
    } else if (method === _ColorAdjustmentNode.HUE) {
      outputNode = hueNode(callParams);
    } else {
      console.error(`${this.type}: Method "${this.method}" not supported!`);
    }
    return outputNode;
  }
};
ColorAdjustmentNode.SATURATION = "saturation";
ColorAdjustmentNode.VIBRANCE = "vibrance";
ColorAdjustmentNode.HUE = "hue";
var ColorAdjustmentNode_default = ColorAdjustmentNode;
var saturation = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.SATURATION);
var vibrance = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.VIBRANCE);
var hue = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.HUE);
var lumaCoeffs = vec3(0.2125, 0.7154, 0.0721);
var luminance = (color2, luma = lumaCoeffs) => dot(color2, luma);
addNodeElement("saturation", saturation);
addNodeElement("vibrance", vibrance);
addNodeElement("hue", hue);
addNodeClass("ColorAdjustmentNode", ColorAdjustmentNode);

// node_modules/three/examples/jsm/nodes/display/NormalMapNode.js
var perturbNormal2Arb = tslFn((inputs) => {
  const { eye_pos, surf_norm, mapN, uv: uv2 } = inputs;
  const q0 = eye_pos.dFdx();
  const q1 = eye_pos.dFdy();
  const st0 = uv2.dFdx();
  const st1 = uv2.dFdy();
  const N = surf_norm;
  const q1perp = q1.cross(N);
  const q0perp = N.cross(q0);
  const T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
  const B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
  const det = T.dot(T).max(B.dot(B));
  const scale = faceDirection.mul(det.inverseSqrt());
  return add(T.mul(mapN.x, scale), B.mul(mapN.y, scale), N.mul(mapN.z)).normalize();
});
var NormalMapNode = class extends TempNode_default {
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  setup(builder) {
    const { normalMapType, scaleNode } = this;
    let normalMap2 = this.node.mul(2).sub(1);
    if (scaleNode !== null) {
      normalMap2 = vec3(normalMap2.xy.mul(scaleNode), normalMap2.z);
    }
    let outputNode = null;
    if (normalMapType === ObjectSpaceNormalMap) {
      outputNode = modelNormalMatrix.mul(normalMap2).normalize();
    } else if (normalMapType === TangentSpaceNormalMap) {
      const tangent = builder.hasGeometryAttribute("tangent");
      if (tangent === true) {
        outputNode = TBNViewMatrix.mul(normalMap2).normalize();
      } else {
        outputNode = perturbNormal2Arb({
          eye_pos: positionView,
          surf_norm: normalView,
          mapN: normalMap2,
          uv: uv()
        });
      }
    }
    return outputNode;
  }
};
var NormalMapNode_default = NormalMapNode;
var normalMap = nodeProxy(NormalMapNode);
var TBNViewMatrix = mat3(tangentView, bitangentView, normalView);
addNodeElement("normalMap", normalMap);
addNodeClass("NormalMapNode", NormalMapNode);

// node_modules/three/examples/jsm/nodes/display/PosterizeNode.js
var PosterizeNode = class extends TempNode_default {
  constructor(sourceNode, stepsNode) {
    super();
    this.sourceNode = sourceNode;
    this.stepsNode = stepsNode;
  }
  setup() {
    const { sourceNode, stepsNode } = this;
    return sourceNode.mul(stepsNode).floor().div(stepsNode);
  }
};
var PosterizeNode_default = PosterizeNode;
var posterize = nodeProxy(PosterizeNode);
addNodeElement("posterize", posterize);
addNodeClass("PosterizeNode", PosterizeNode);

// node_modules/three/examples/jsm/nodes/display/ToneMappingNode.js
var LinearToneMappingNode = tslFn(({ color: color2, exposure }) => {
  return color2.mul(exposure).clamp();
});
var ReinhardToneMappingNode = tslFn(({ color: color2, exposure }) => {
  color2 = color2.mul(exposure);
  return color2.div(color2.add(1)).clamp();
});
var OptimizedCineonToneMappingNode = tslFn(({ color: color2, exposure }) => {
  color2 = color2.mul(exposure);
  color2 = color2.sub(4e-3).max(0);
  const a = color2.mul(color2.mul(6.2).add(0.5));
  const b = color2.mul(color2.mul(6.2).add(1.7)).add(0.06);
  return a.div(b).pow(2.2);
});
var RRTAndODTFit = tslFn(({ color: color2 }) => {
  const a = color2.mul(color2.add(0.0245786)).sub(90537e-9);
  const b = color2.mul(color2.add(0.432951).mul(0.983729)).add(0.238081);
  return a.div(b);
});
var ACESFilmicToneMappingNode = tslFn(({ color: color2, exposure }) => {
  const ACESInputMat = mat3(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  );
  const ACESOutputMat = mat3(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  color2 = color2.mul(exposure).div(0.6);
  color2 = ACESInputMat.mul(color2);
  color2 = RRTAndODTFit({ color: color2 });
  color2 = ACESOutputMat.mul(color2);
  return color2.clamp();
});
var toneMappingLib = {
  [LinearToneMapping]: LinearToneMappingNode,
  [ReinhardToneMapping]: ReinhardToneMappingNode,
  [CineonToneMapping]: OptimizedCineonToneMappingNode,
  [ACESFilmicToneMapping]: ACESFilmicToneMappingNode
};
var ToneMappingNode = class extends TempNode_default {
  constructor(toneMapping2 = NoToneMapping, exposureNode = float(1), colorNode = null) {
    super("vec3");
    this.toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  getCacheKey() {
    let cacheKey = super.getCacheKey();
    cacheKey = "{toneMapping:" + this.toneMapping + ",nodes:" + cacheKey + "}";
    return cacheKey;
  }
  setup(builder) {
    const colorNode = this.colorNode || builder.context.color;
    const toneMapping2 = this.toneMapping;
    if (toneMapping2 === NoToneMapping)
      return colorNode;
    const toneMappingParams = { exposure: this.exposureNode, color: colorNode };
    const toneMappingNode = toneMappingLib[toneMapping2];
    let outputNode = null;
    if (toneMappingNode) {
      outputNode = toneMappingNode(toneMappingParams);
    } else {
      console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", toneMapping2);
      outputNode = colorNode;
    }
    return outputNode;
  }
};
var ToneMappingNode_default = ToneMappingNode;
var toneMapping = (mapping, exposure, color2) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color2)));
addNodeClass("ToneMappingNode", ToneMappingNode);

// node_modules/three/examples/jsm/nodes/display/ViewportSharedTextureNode.js
var sharedFramebuffer = null;
var ViewportSharedTextureNode = class extends ViewportTextureNode_default {
  constructor(uvNode = viewportTopLeft, levelNode = null) {
    if (sharedFramebuffer === null) {
      sharedFramebuffer = new FramebufferTexture();
    }
    super(uvNode, levelNode, sharedFramebuffer);
  }
};
var ViewportSharedTextureNode_default = ViewportSharedTextureNode;
var viewportSharedTexture = nodeProxy(ViewportSharedTextureNode);
addNodeElement("viewportSharedTexture", viewportSharedTexture);
addNodeClass("ViewportSharedTextureNode", ViewportSharedTextureNode);

// node_modules/three/examples/jsm/nodes/code/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code2 = "", includes3 = [], language = "") {
    super("code");
    this.isCodeNode = true;
    this.code = code2;
    this.language = language;
    this._includes = includes3;
  }
  setIncludes(includes3) {
    this._includes = includes3;
    return this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(builder) {
    const includes3 = this.getIncludes(builder);
    for (const include of includes3) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
  serialize(data) {
    super.serialize(data);
    data.code = this.code;
    data.language = this.language;
  }
  deserialize(data) {
    super.deserialize(data);
    this.code = data.code;
    this.language = data.language;
  }
};
var CodeNode_default = CodeNode;
var code = nodeProxy(CodeNode);
var js = (src, includes3) => code(src, includes3, "js");
var wgsl = (src, includes3) => code(src, includes3, "wgsl");
var glsl = (src, includes3) => code(src, includes3, "glsl");
addNodeClass("CodeNode", CodeNode);

// node_modules/three/examples/jsm/nodes/code/FunctionCallNode.js
var FunctionCallNode = class extends TempNode_default {
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    if (Array.isArray(parameters)) {
      for (let i = 0; i < parameters.length; i++) {
        const inputNode = inputs[i];
        const node = parameters[i];
        params.push(node.build(builder, inputNode.type));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(node.build(builder, inputNode.type));
        } else {
          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var FunctionCallNode_default = FunctionCallNode;
var call = (func, ...params) => {
  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);
  return nodeObject(new FunctionCallNode(nodeObject(func), params));
};
addNodeElement("call", call);
addNodeClass("FunctionCallNode", FunctionCallNode);

// node_modules/three/examples/jsm/nodes/code/FunctionNode.js
var FunctionNode = class extends CodeNode_default {
  constructor(code2 = "", includes3 = [], language = "") {
    super(code2, includes3, language);
    this.keywords = {};
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  generate(builder, output2) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    let code2 = this.getNodeFunction(builder).getCode(propertyName);
    const keywords = this.keywords;
    const keywordsProperties = Object.keys(keywords);
    if (keywordsProperties.length > 0) {
      for (const property2 of keywordsProperties) {
        const propertyRegExp = new RegExp(`\\b${property2}\\b`, "g");
        const nodeProperty = keywords[property2].build(builder, "property");
        code2 = code2.replace(propertyRegExp, nodeProperty);
      }
    }
    nodeCode.code = code2 + "\n";
    if (output2 === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output2);
    }
  }
};
var FunctionNode_default = FunctionNode;
var nativeFn = (code2, includes3 = [], language = "") => {
  for (let i = 0; i < includes3.length; i++) {
    const include = includes3[i];
    if (typeof include === "function") {
      includes3[i] = include.functionNode;
    }
  }
  const functionNode = nodeObject(new FunctionNode(code2, includes3, language));
  const fn = (...params) => functionNode.call(...params);
  fn.functionNode = functionNode;
  return fn;
};
var glslFn = (code2, includes3) => nativeFn(code2, includes3, "glsl");
var wgslFn = (code2, includes3) => nativeFn(code2, includes3, "wgsl");
addNodeClass("FunctionNode", FunctionNode);

// node_modules/three/examples/jsm/nodes/code/ScriptableValueNode.js
var ScriptableValueNode = class extends Node_default {
  constructor(value = null) {
    super();
    this._value = value;
    this._cache = null;
    this.inputType = null;
    this.outpuType = null;
    this.events = new EventDispatcher();
    this.isScriptableValueNode = true;
  }
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(val) {
    if (this._value === val)
      return;
    if (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer) {
      URL.revokeObjectURL(this._cache);
      this._cache = null;
    }
    this._value = val;
    this.events.dispatchEvent({ type: "change" });
    this.refresh();
  }
  get value() {
    return this._value;
  }
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  getValue() {
    const value = this.value;
    if (value && this._cache === null && this.inputType === "URL" && value.value instanceof ArrayBuffer) {
      this._cache = URL.createObjectURL(new Blob([value.value]));
    } else if (value && value.value !== null && value.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof value.value === "string" || this.inputType === "Number" && typeof value.value === "number" || this.inputType === "Vector2" && value.value.isVector2 || this.inputType === "Vector3" && value.value.isVector3 || this.inputType === "Vector4" && value.value.isVector4 || this.inputType === "Color" && value.value.isColor || this.inputType === "Matrix3" && value.value.isMatrix3 || this.inputType === "Matrix4" && value.value.isMatrix4)) {
      return value.value;
    }
    return this._cache || value;
  }
  getNodeType(builder) {
    return this.value && this.value.isNode ? this.value.getNodeType(builder) : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : float();
  }
  serialize(data) {
    super.serialize(data);
    if (this.value !== null) {
      if (this.inputType === "ArrayBuffer") {
        data.value = arrayBufferToBase64(this.value);
      } else {
        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
      }
    } else {
      data.value = null;
    }
    data.inputType = this.inputType;
    data.outputType = this.outputType;
  }
  deserialize(data) {
    super.deserialize(data);
    let value = null;
    if (data.value !== null) {
      if (data.inputType === "ArrayBuffer") {
        value = base64ToArrayBuffer(data.value);
      } else if (data.inputType === "Texture") {
        value = data.meta.textures[data.value];
      } else {
        value = data.meta.nodes[data.value] || null;
      }
    }
    this.value = value;
    this.inputType = data.inputType;
    this.outputType = data.outputType;
  }
};
var ScriptableValueNode_default = ScriptableValueNode;
var scriptableValue = nodeProxy(ScriptableValueNode);
addNodeElement("scriptableValue", scriptableValue);
addNodeClass("ScriptableValueNode", ScriptableValueNode);

// node_modules/three/examples/jsm/nodes/code/ScriptableNode.js
var Resources = class extends Map {
  get(key, callback = null, ...params) {
    if (this.has(key))
      return super.get(key);
    if (callback !== null) {
      const value = callback(...params);
      this.set(key, value);
      return value;
    }
  }
};
var Parameters = class {
  constructor(scriptableNode) {
    this.scriptableNode = scriptableNode;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(id2) {
    return this.scriptableNode.getInputLayout(id2);
  }
  get(name) {
    const param = this.parameters[name];
    const value = param ? param.getValue() : null;
    return value;
  }
};
var global = new Resources();
var ScriptableNode = class extends Node_default {
  constructor(codeNode = null, parameters = {}) {
    super();
    this.codeNode = codeNode;
    this.parameters = parameters;
    this._local = new Resources();
    this._output = scriptableValue();
    this._outputs = {};
    this._source = this.source;
    this._method = null;
    this._object = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this.onRefresh = this.onRefresh.bind(this);
    this.isScriptableNode = true;
  }
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  setLocal(name, value) {
    return this._local.set(name, value);
  }
  getLocal(name) {
    return this._local.get(name);
  }
  onRefresh() {
    this._refresh();
  }
  getInputLayout(id2) {
    for (const element2 of this.getLayout()) {
      if (element2.inputType && (element2.id === id2 || element2.name === id2)) {
        return element2;
      }
    }
  }
  getOutputLayout(id2) {
    for (const element2 of this.getLayout()) {
      if (element2.outputType && (element2.id === id2 || element2.name === id2)) {
        return element2;
      }
    }
  }
  setOutput(name, value) {
    const outputs = this._outputs;
    if (outputs[name] === void 0) {
      outputs[name] = scriptableValue(value);
    } else {
      outputs[name].value = value;
    }
    return this;
  }
  getOutput(name) {
    return this._outputs[name];
  }
  getParameter(name) {
    return this.parameters[name];
  }
  setParameter(name, value) {
    const parameters = this.parameters;
    if (value && value.isScriptableNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].getDefaultOutput().events.addEventListener("refresh", this.onRefresh);
    } else if (value && value.isScriptableValueNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else if (parameters[name] === void 0) {
      parameters[name] = scriptableValue(value);
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else {
      parameters[name].value = value;
    }
    return this;
  }
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  deleteParameter(name) {
    let valueNode = this.parameters[name];
    if (valueNode) {
      if (valueNode.isScriptableNode)
        valueNode = valueNode.getDefaultOutput();
      valueNode.events.removeEventListener("refresh", this.onRefresh);
    }
    return this;
  }
  clearParameters() {
    for (const name of Object.keys(this.parameters)) {
      this.deleteParameter(name);
    }
    this.needsUpdate = true;
    return this;
  }
  call(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method(...params);
    }
  }
  async callAsync(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method.constructor.name === "AsyncFunction" ? await method(...params) : method(...params);
    }
  }
  getNodeType(builder) {
    return this.getDefaultOutputNode().getNodeType(builder);
  }
  refresh(output2 = null) {
    if (output2 !== null) {
      this.getOutput(output2).refresh();
    } else {
      this._refresh();
    }
  }
  getObject() {
    if (this.needsUpdate)
      this.dispose();
    if (this._object !== null)
      return this._object;
    const refresh = () => this.refresh();
    const setOutput = (id2, value) => this.setOutput(id2, value);
    const parameters = new Parameters(this);
    const THREE = global.get("THREE");
    const TSL = global.get("TSL");
    const method = this.getMethod(this.codeNode);
    const params = [parameters, this._local, global, refresh, setOutput, THREE, TSL];
    this._object = method(...params);
    const layout = this._object.layout;
    if (layout) {
      if (layout.cache === false) {
        this._local.clear();
      }
      this._output.outputType = layout.outputType || null;
      if (Array.isArray(layout.elements)) {
        for (const element2 of layout.elements) {
          const id2 = element2.id || element2.name;
          if (element2.inputType) {
            if (this.getParameter(id2) === void 0)
              this.setParameter(id2, null);
            this.getParameter(id2).inputType = element2.inputType;
          }
          if (element2.outputType) {
            if (this.getOutput(id2) === void 0)
              this.setOutput(id2, null);
            this.getOutput(id2).outputType = element2.outputType;
          }
        }
      }
    }
    return this._object;
  }
  deserialize(data) {
    super.deserialize(data);
    for (const name in this.parameters) {
      let valueNode = this.parameters[name];
      if (valueNode.isScriptableNode)
        valueNode = valueNode.getDefaultOutput();
      valueNode.events.addEventListener("refresh", this.onRefresh);
    }
  }
  getLayout() {
    return this.getObject().layout;
  }
  getDefaultOutputNode() {
    const output2 = this.getDefaultOutput().value;
    if (output2 && output2.isNode) {
      return output2;
    }
    return float();
  }
  getDefaultOutput() {
    return this._exec()._output;
  }
  getMethod() {
    if (this.needsUpdate)
      this.dispose();
    if (this._method !== null)
      return this._method;
    const parametersProps = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"];
    const interfaceProps = ["layout", "init", "main", "dispose"];
    const properties = interfaceProps.join(", ");
    const declarations = "var " + properties + "; var output = {};\n";
    const returns = "\nreturn { ...output, " + properties + " };";
    const code2 = declarations + this.codeNode.code + returns;
    this._method = new Function(...parametersProps, code2);
    return this._method;
  }
  dispose() {
    if (this._method === null)
      return;
    if (this._object && typeof this._object.dispose === "function") {
      this._object.dispose();
    }
    this._method = null;
    this._object = null;
    this._source = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this._output.value = null;
    this._outputs = {};
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  set needsUpdate(value) {
    if (value === true)
      this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  _exec() {
    if (this.codeNode === null)
      return this;
    if (this._needsOutputUpdate === true) {
      this._value = this.call("main");
      this._needsOutputUpdate = false;
    }
    this._output.value = this._value;
    return this;
  }
  _refresh() {
    this.needsUpdate = true;
    this._exec();
    this._output.refresh();
  }
};
var ScriptableNode_default = ScriptableNode;
var scriptable = nodeProxy(ScriptableNode);
addNodeElement("scriptable", scriptable);
addNodeClass("ScriptableNode", ScriptableNode);

// node_modules/three/examples/jsm/nodes/fog/FogNode.js
var FogNode = class extends Node_default {
  constructor(colorNode, factorNode) {
    super("float");
    this.isFogNode = true;
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  mixAssign(outputNode) {
    return this.mix(outputNode, this.colorNode);
  }
  setup() {
    return this.factorNode;
  }
};
var FogNode_default = FogNode;
var fog = nodeProxy(FogNode);
addNodeElement("fog", fog);
addNodeClass("FogNode", FogNode);

// node_modules/three/examples/jsm/nodes/fog/FogRangeNode.js
var FogRangeNode = class extends FogNode_default {
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.isFogRangeNode = true;
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  setup() {
    return smoothstep(this.nearNode, this.farNode, positionView.z.negate());
  }
};
var FogRangeNode_default = FogRangeNode;
var rangeFog = nodeProxy(FogRangeNode);
addNodeElement("rangeFog", rangeFog);
addNodeClass("FogRangeNode", FogRangeNode);

// node_modules/three/examples/jsm/nodes/fog/FogExp2Node.js
var FogExp2Node = class extends FogNode_default {
  constructor(colorNode, densityNode) {
    super(colorNode);
    this.isFogExp2Node = true;
    this.densityNode = densityNode;
  }
  setup() {
    const depthNode = positionView.z.negate();
    const densityNode = this.densityNode;
    return densityNode.mul(densityNode, depthNode, depthNode).negate().exp().oneMinus();
  }
};
var FogExp2Node_default = FogExp2Node;
var densityFog = nodeProxy(FogExp2Node);
addNodeElement("densityFog", densityFog);
addNodeClass("FogExp2Node", FogExp2Node);

// node_modules/three/examples/jsm/nodes/geometry/RangeNode.js
var min2 = null;
var max2 = null;
var RangeNode = class extends Node_default {
  constructor(minNode = float(), maxNode = float()) {
    super();
    this.minNode = minNode;
    this.maxNode = maxNode;
  }
  getVectorLength(builder) {
    const minLength = builder.getTypeLength(getValueType(this.minNode.value));
    const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));
    return minLength > maxLength ? minLength : maxLength;
  }
  getNodeType(builder) {
    return builder.object.isInstancedMesh === true ? builder.getTypeFromLength(this.getVectorLength(builder)) : "float";
  }
  setup(builder) {
    const object = builder.object;
    let output2 = null;
    if (object.isInstancedMesh === true) {
      const minValue = this.minNode.value;
      const maxValue = this.maxNode.value;
      const minLength = builder.getTypeLength(getValueType(minValue));
      const maxLength = builder.getTypeLength(getValueType(maxValue));
      min2 = min2 || new Vector4();
      max2 = max2 || new Vector4();
      min2.setScalar(0);
      max2.setScalar(0);
      if (minLength === 1)
        min2.setScalar(minValue);
      else if (minValue.isColor)
        min2.set(minValue.r, minValue.g, minValue.b);
      else
        min2.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
      if (maxLength === 1)
        max2.setScalar(maxValue);
      else if (maxValue.isColor)
        max2.set(maxValue.r, maxValue.g, maxValue.b);
      else
        max2.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
      const stride = 4;
      const length2 = stride * object.count;
      const array = new Float32Array(length2);
      for (let i = 0; i < length2; i++) {
        const index = i % stride;
        const minElementValue = min2.getComponent(index);
        const maxElementValue = max2.getComponent(index);
        array[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());
      }
      const nodeType = this.getNodeType(builder);
      output2 = buffer(array, "vec4", object.count).element(instanceIndex).convert(nodeType);
    } else {
      output2 = float(0);
    }
    return output2;
  }
};
var RangeNode_default = RangeNode;
var range = nodeProxy(RangeNode);
addNodeClass("RangeNode", RangeNode);

// node_modules/three/examples/jsm/nodes/gpgpu/ComputeNode.js
var ComputeNode = class extends Node_default {
  constructor(computeNode, count, workgroupSize = [64]) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.count = count;
    this.workgroupSize = workgroupSize;
    this.dispatchCount = 0;
    this.version = 1;
    this.updateBeforeType = NodeUpdateType.OBJECT;
    this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  updateDispatchCount() {
    const { count, workgroupSize } = this;
    let size = workgroupSize[0];
    for (let i = 1; i < workgroupSize.length; i++)
      size *= workgroupSize[i];
    this.dispatchCount = Math.ceil(count / size);
  }
  onInit() {
  }
  updateBefore({ renderer }) {
    renderer.compute(this);
  }
  generate(builder) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addLineFlowCode(snippet);
      }
    }
  }
};
var ComputeNode_default = ComputeNode;
var compute = (node, count, workgroupSize) => nodeObject(new ComputeNode(nodeObject(node), count, workgroupSize));
addNodeElement("compute", compute);
addNodeClass("ComputeNode", ComputeNode);

// node_modules/three/examples/jsm/nodes/lighting/LightNode.js
var LightNode = class _LightNode extends Node_default {
  constructor(scope = _LightNode.TARGET_DIRECTION, light = null) {
    super();
    this.scope = scope;
    this.light = light;
  }
  setup() {
    const { scope, light } = this;
    let output2 = null;
    if (scope === _LightNode.TARGET_DIRECTION) {
      output2 = cameraViewMatrix.transformDirection(objectPosition(light).sub(objectPosition(light.target)));
    }
    return output2;
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
LightNode.TARGET_DIRECTION = "targetDirection";
var LightNode_default = LightNode;
var lightTargetDirection = nodeProxy(LightNode, LightNode.TARGET_DIRECTION);
addNodeClass("LightNode", LightNode);

// node_modules/three/examples/jsm/nodes/lighting/LightUtils.js
var getDistanceAttenuation = tslFn((inputs) => {
  const { lightDistance, cutoffDistance, decayExponent } = inputs;
  const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();
  return cutoffDistance.greaterThan(0).cond(
    distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()),
    distanceFalloff
  );
});

// node_modules/three/examples/jsm/nodes/lighting/PointLightNode.js
var PointLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  setup(builder) {
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lightingModel = builder.context.lightingModel;
    const lVector = objectViewPosition(light).sub(positionView);
    const lightDirection = lVector.normalize();
    const lightDistance = lVector.length();
    const lightAttenuation = getDistanceAttenuation({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const lightColor = colorNode.mul(lightAttenuation);
    const reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection,
      lightColor,
      reflectedLight
    }, builder.stack, builder);
  }
};
var PointLightNode_default = PointLightNode;
addNodeClass("PointLightNode", PointLightNode);
addLightNode(PointLight, PointLightNode);

// node_modules/three/examples/jsm/nodes/lighting/DirectionalLightNode.js
var DirectionalLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
  }
  setup(builder) {
    super.setup(builder);
    const lightingModel = builder.context.lightingModel;
    const lightColor = this.colorNode;
    const lightDirection = lightTargetDirection(this.light);
    const reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection,
      lightColor,
      reflectedLight
    }, builder.stack, builder);
  }
};
var DirectionalLightNode_default = DirectionalLightNode;
addNodeClass("DirectionalLightNode", DirectionalLightNode);
addLightNode(DirectionalLight, DirectionalLightNode);

// node_modules/three/examples/jsm/nodes/lighting/SpotLightNode.js
var SpotLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.coneCosNode = uniform(0);
    this.penumbraCosNode = uniform(0);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    super.update(frame);
    const { light } = this;
    this.coneCosNode.value = Math.cos(light.angle);
    this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  getSpotAttenuation(angleCosine) {
    const { coneCosNode, penumbraCosNode } = this;
    return smoothstep(coneCosNode, penumbraCosNode, angleCosine);
  }
  setup(builder) {
    super.setup(builder);
    const lightingModel = builder.context.lightingModel;
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lVector = objectViewPosition(light).sub(positionView);
    const lightDirection = lVector.normalize();
    const angleCos = lightDirection.dot(lightTargetDirection(light));
    const spotAttenuation = this.getSpotAttenuation(angleCos);
    const lightDistance = lVector.length();
    const lightAttenuation = getDistanceAttenuation({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);
    const reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection,
      lightColor,
      reflectedLight
    }, builder.stack, builder);
  }
};
var SpotLightNode_default = SpotLightNode;
addNodeClass("SpotLightNode", SpotLightNode);
addLightNode(SpotLight, SpotLightNode);

// node_modules/three/examples/jsm/lights/IESSpotLight.js
var IESSpotLight = class extends SpotLight {
  constructor(color2, intensity, distance2, angle, penumbra, decay) {
    super(color2, intensity, distance2, angle, penumbra, decay);
    this.iesMap = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.iesMap = source.iesMap;
    return this;
  }
};
var IESSpotLight_default = IESSpotLight;

// node_modules/three/examples/jsm/nodes/lighting/IESSpotLightNode.js
var IESSpotLightNode = class extends SpotLightNode_default {
  getSpotAttenuation(angleCosine) {
    const iesMap = this.light.iesMap;
    let spotAttenuation = null;
    if (iesMap && iesMap.isTexture === true) {
      const angle = angleCosine.acos().mul(1 / Math.PI);
      spotAttenuation = texture(iesMap, vec2(angle, 0), 0).r;
    } else {
      spotAttenuation = super.getSpotAttenuation(angleCosine);
    }
    return spotAttenuation;
  }
};
var IESSpotLightNode_default = IESSpotLightNode;
addNodeClass("IESSpotLightNode", IESSpotLightNode);
addLightNode(IESSpotLight_default, IESSpotLightNode);

// node_modules/three/examples/jsm/nodes/lighting/AmbientLightNode.js
var AmbientLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
  }
  setup({ context: context2 }) {
    context2.irradiance.addAssign(this.colorNode);
  }
};
var AmbientLightNode_default = AmbientLightNode;
addNodeClass("AmbientLightNode", AmbientLightNode);
addLightNode(AmbientLight, AmbientLightNode);

// node_modules/three/examples/jsm/nodes/lighting/HemisphereLightNode.js
var HemisphereLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.lightPositionNode = objectPosition(light);
    this.lightDirectionNode = this.lightPositionNode.normalize();
    this.groundColorNode = uniform(new Color());
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.lightPositionNode.object3d = light;
    this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);
  }
  setup(builder) {
    const { colorNode, groundColorNode, lightDirectionNode } = this;
    const dotNL = normalView.dot(lightDirectionNode);
    const hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);
    const irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);
    builder.context.irradiance.addAssign(irradiance);
  }
};
var HemisphereLightNode_default = HemisphereLightNode;
addNodeClass("HemisphereLightNode", HemisphereLightNode);
addLightNode(HemisphereLight, HemisphereLightNode);

// node_modules/three/examples/jsm/nodes/procedural/CheckerNode.js
var checkerShaderNode = tslFn((inputs) => {
  const uv2 = inputs.uv.mul(2);
  const cx = uv2.x.floor();
  const cy = uv2.y.floor();
  const result = cx.add(cy).mod(2);
  return result.sign();
});
var CheckerNode = class extends TempNode_default {
  constructor(uvNode = uv()) {
    super("float");
    this.uvNode = uvNode;
  }
  setup() {
    return checkerShaderNode({ uv: this.uvNode });
  }
};
var CheckerNode_default = CheckerNode;
var checker = nodeProxy(CheckerNode);
addNodeElement("checker", checker);
addNodeClass("CheckerNode", CheckerNode);

// node_modules/three/examples/jsm/nodes/loaders/NodeLoader.js
var NodeLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (text) => {
      try {
        onLoad(this.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        this.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parseNodes(json) {
    const nodes = {};
    if (json !== void 0) {
      for (const nodeJSON of json) {
        const { uuid, type } = nodeJSON;
        nodes[uuid] = nodeObject(createNodeFromType(type));
        nodes[uuid].uuid = uuid;
      }
      const meta = { nodes, textures: this.textures };
      for (const nodeJSON of json) {
        nodeJSON.meta = meta;
        const node = nodes[nodeJSON.uuid];
        node.deserialize(nodeJSON);
        delete nodeJSON.meta;
      }
    }
    return nodes;
  }
  parse(json) {
    const node = nodeObject(createNodeFromType(json.type));
    node.uuid = json.uuid;
    const nodes = this.parseNodes(json.nodes);
    const meta = { nodes, textures: this.textures };
    json.meta = meta;
    node.deserialize(json);
    delete json.meta;
    return node;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
};
var NodeLoader_default = NodeLoader;

// node_modules/three/examples/jsm/nodes/materials/InstancedPointsNodeMaterial.js
var defaultValues = new PointsMaterial();
var InstancedPointsNodeMaterial = class extends NodeMaterial_default {
  constructor(params = {}) {
    super();
    this.normals = false;
    this.lights = false;
    this.useAlphaToCoverage = true;
    this.useColor = params.vertexColors;
    this.pointWidth = 1;
    this.pointColorNode = null;
    this.setDefaultValues(defaultValues);
    this.setupShaders();
    this.setValues(params);
  }
  setupShaders() {
    const useAlphaToCoverage = this.alphaToCoverage;
    const useColor = this.useColor;
    this.vertexNode = tslFn(() => {
      varying(vec2(), "vUv").assign(uv());
      const instancePosition = attribute("instancePosition");
      const mvPos = property("vec4", "mvPos");
      mvPos.assign(modelViewMatrix.mul(vec4(instancePosition, 1)));
      const aspect = viewport.z.div(viewport.w);
      const clipPos = cameraProjectionMatrix.mul(mvPos);
      const offset = property("vec2", "offset");
      offset.assign(positionGeometry.xy);
      offset.assign(offset.mul(materialPointWidth));
      offset.assign(offset.div(viewport.z));
      offset.y.assign(offset.y.mul(aspect));
      offset.assign(offset.mul(clipPos.w));
      clipPos.assign(clipPos.add(vec4(offset, 0, 0)));
      return clipPos;
    })();
    this.fragmentNode = tslFn(() => {
      const vUv = varying(vec2(), "vUv");
      const alpha = property("float", "alpha");
      alpha.assign(1);
      const a = vUv.x;
      const b = vUv.y;
      const len2 = a.mul(a).add(b.mul(b));
      if (useAlphaToCoverage) {
        const dlen = property("float", "dlen");
        dlen.assign(len2.fwidth());
        alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());
      } else {
        len2.greaterThan(1).discard();
      }
      let pointColorNode;
      if (this.pointColorNode) {
        pointColorNode = this.pointColorNode;
      } else {
        if (useColor) {
          const instanceColor = attribute("instanceColor");
          pointColorNode = instanceColor.mul(materialColor);
        } else {
          pointColorNode = materialColor;
        }
      }
      return vec4(pointColorNode, alpha);
    })();
    this.needsUpdate = true;
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(value) {
    if (this.useAlphaToCoverage !== value) {
      this.useAlphaToCoverage = value;
      this.setupShaders();
    }
  }
};
var InstancedPointsNodeMaterial_default = InstancedPointsNodeMaterial;
addNodeMaterial("InstancedPointsNodeMaterial", InstancedPointsNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/LineBasicNodeMaterial.js
var defaultValues2 = new LineBasicMaterial();
var LineBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isLineBasicNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.setDefaultValues(defaultValues2);
    this.setValues(parameters);
  }
};
var LineBasicNodeMaterial_default = LineBasicNodeMaterial;
addNodeMaterial("LineBasicNodeMaterial", LineBasicNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/LineDashedNodeMaterial.js
var defaultValues3 = new LineDashedMaterial();
var LineDashedNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isLineDashedNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.setDefaultValues(defaultValues3);
    this.offsetNode = null;
    this.dashScaleNode = null;
    this.dashSizeNode = null;
    this.gapSizeNode = null;
    this.setValues(parameters);
  }
  setupVariants() {
    const offsetNode = this.offsetNode;
    const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;
    const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;
    const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;
    dashSize.assign(dashSizeNode);
    gapSize.assign(gapSizeNode);
    const vLineDistance = varying(attribute("lineDistance").mul(dashScaleNode));
    const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;
    vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();
  }
};
var LineDashedNodeMaterial_default = LineDashedNodeMaterial;
addNodeMaterial("LineDashedNodeMaterial", LineDashedNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/Line2NodeMaterial.js
var defaultValues4 = new LineDashedMaterial();
var Line2NodeMaterial = class extends NodeMaterial_default {
  constructor(params = {}) {
    super();
    this.normals = false;
    this.lights = false;
    this.setDefaultValues(defaultValues4);
    this.useAlphaToCoverage = true;
    this.useColor = params.vertexColors;
    this.useDash = params.dashed;
    this.useWorldUnits = false;
    this.dashOffset = 0;
    this.lineWidth = 1;
    this.lineColorNode = null;
    this.offsetNode = null;
    this.dashScaleNode = null;
    this.dashSizeNode = null;
    this.gapSizeNode = null;
    this.setupShaders();
    this.setValues(params);
  }
  setupShaders() {
    const useAlphaToCoverage = this.alphaToCoverage;
    const useColor = this.useColor;
    const useDash = this.dashed;
    const useWorldUnits = this.worldUnits;
    const trimSegment = tslFn(({ start, end }) => {
      const a = cameraProjectionMatrix.element(2).element(2);
      const b = cameraProjectionMatrix.element(3).element(2);
      const nearEstimate = b.mul(-0.5).div(a);
      const alpha = nearEstimate.sub(start.z).div(end.z.sub(start.z));
      return vec4(mix(start.xyz, end.xyz, alpha), end.w);
    });
    this.vertexNode = tslFn(() => {
      varyingProperty("vec2", "vUv").assign(uv());
      const instanceStart = attribute("instanceStart");
      const instanceEnd = attribute("instanceEnd");
      const start = property("vec4", "start");
      const end = property("vec4", "end");
      start.assign(modelViewMatrix.mul(vec4(instanceStart, 1)));
      end.assign(modelViewMatrix.mul(vec4(instanceEnd, 1)));
      if (useWorldUnits) {
        varyingProperty("vec3", "worldStart").assign(start.xyz);
        varyingProperty("vec3", "worldEnd").assign(end.xyz);
      }
      const aspect = viewport.z.div(viewport.w);
      const perspective = cameraProjectionMatrix.element(2).element(3).equal(-1);
      If(perspective, () => {
        If(start.z.lessThan(0).and(end.z.greaterThan(0)), () => {
          end.assign(trimSegment({ start, end }));
        }).elseif(end.z.lessThan(0).and(start.z.greaterThanEqual(0)), () => {
          start.assign(trimSegment({ start: end, end: start }));
        });
      });
      const clipStart = cameraProjectionMatrix.mul(start);
      const clipEnd = cameraProjectionMatrix.mul(end);
      const ndcStart = clipStart.xyz.div(clipStart.w);
      const ndcEnd = clipEnd.xyz.div(clipEnd.w);
      const dir = ndcEnd.xy.sub(ndcStart.xy).temp();
      dir.x.assign(dir.x.mul(aspect));
      dir.assign(dir.normalize());
      const clip = temp(vec4());
      if (useWorldUnits) {
        const worldDir = end.xyz.sub(start.xyz).normalize();
        const offset = positionGeometry.y.lessThan(0.5).cond(
          start.xyz.cross(worldDir).normalize(),
          end.xyz.cross(worldDir).normalize()
        );
        offset.assign(positionGeometry.x.lessThan(0).cond(offset.negate(), offset));
        const forwardOffset = worldDir.dot(vec3(0, 0, 1));
        if (!useDash) {
          start.assign(start.sub(vec4(worldDir.mul(materialLineWidth).mul(0.5), 0)));
          end.assign(end.add(vec4(worldDir.mul(materialLineWidth).mul(0.5), 0)));
          offset.assign(offset.sub(vec3(dir.mul(forwardOffset), 0)));
          offset.z.assign(offset.z.add(0.5));
        }
        If(positionGeometry.y.greaterThan(1).or(positionGeometry.y.lessThan(0)), () => {
          offset.assign(offset.add(vec3(dir.mul(2).mul(forwardOffset), 0)));
        });
        offset.assign(offset.mul(materialLineWidth).mul(0.5));
        const worldPos = varyingProperty("vec4", "worldPos");
        worldPos.assign(positionGeometry.y.lessThan(0.5).cond(start, end));
        worldPos.assign(worldPos.add(vec4(offset, 0)));
        clip.assign(cameraProjectionMatrix.mul(worldPos));
        const clipPose = temp(vec3());
        clipPose.assign(positionGeometry.y.lessThan(0.5).cond(ndcStart, ndcEnd));
        clip.z.assign(clipPose.z.mul(clip.w));
      } else {
        const offset = property("vec2", "offset");
        offset.assign(vec2(dir.y, dir.x.negate()));
        dir.x.assign(dir.x.div(aspect));
        offset.x.assign(offset.x.div(aspect));
        offset.assign(positionGeometry.x.lessThan(0).cond(offset.negate(), offset));
        If(positionGeometry.y.lessThan(0), () => {
          offset.assign(offset.sub(dir));
        }).elseif(positionGeometry.y.greaterThan(1), () => {
          offset.assign(offset.add(dir));
        });
        offset.assign(offset.mul(materialLineWidth));
        offset.assign(offset.div(viewport.w));
        clip.assign(positionGeometry.y.lessThan(0.5).cond(clipStart, clipEnd));
        offset.assign(offset.mul(clip.w));
        clip.assign(clip.add(vec4(offset, 0, 0)));
      }
      return clip;
    })();
    const closestLineToLine = tslFn(({ p1, p2, p3, p4 }) => {
      const p13 = p1.sub(p3);
      const p43 = p4.sub(p3);
      const p21 = p2.sub(p1);
      const d1343 = p13.dot(p43);
      const d4321 = p43.dot(p21);
      const d1321 = p13.dot(p21);
      const d4343 = p43.dot(p43);
      const d2121 = p21.dot(p21);
      const denom = d2121.mul(d4343).sub(d4321.mul(d4321));
      const numer = d1343.mul(d4321).sub(d1321.mul(d4343));
      const mua = numer.div(denom).clamp();
      const mub = d1343.add(d4321.mul(mua)).div(d4343).clamp();
      return vec2(mua, mub);
    });
    this.fragmentNode = tslFn(() => {
      const vUv = varyingProperty("vec2", "vUv");
      if (useDash) {
        const offsetNode = this.offsetNode ? float(this.offsetNodeNode) : materialLineDashOffset;
        const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;
        const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;
        const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;
        dashSize.assign(dashSizeNode);
        gapSize.assign(gapSizeNode);
        const instanceDistanceStart = attribute("instanceDistanceStart");
        const instanceDistanceEnd = attribute("instanceDistanceEnd");
        const lineDistance = positionGeometry.y.lessThan(0.5).cond(dashScaleNode.mul(instanceDistanceStart), materialLineScale.mul(instanceDistanceEnd));
        const vLineDistance = varying(lineDistance.add(materialLineDashOffset));
        const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;
        vUv.y.lessThan(-1).or(vUv.y.greaterThan(1)).discard();
        vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();
      }
      const alpha = property("float", "alpha");
      alpha.assign(1);
      if (useWorldUnits) {
        const worldStart = varyingProperty("vec3", "worldStart");
        const worldEnd = varyingProperty("vec3", "worldEnd");
        const rayEnd = varyingProperty("vec4", "worldPos").xyz.normalize().mul(1e5);
        const lineDir = worldEnd.sub(worldStart);
        const params = closestLineToLine({ p1: worldStart, p2: worldEnd, p3: vec3(0, 0, 0), p4: rayEnd });
        const p1 = worldStart.add(lineDir.mul(params.x));
        const p2 = rayEnd.mul(params.y);
        const delta = p1.sub(p2);
        const len = delta.length();
        const norm = len.div(materialLineWidth);
        if (!useDash) {
          if (useAlphaToCoverage) {
            const dnorm = norm.fwidth();
            alpha.assign(smoothstep(dnorm.negate().add(0.5), dnorm.add(0.5), norm).oneMinus());
          } else {
            norm.greaterThan(0.5).discard();
          }
        }
      } else {
        if (useAlphaToCoverage) {
          const a = vUv.x;
          const b = vUv.y.greaterThan(0).cond(vUv.y.sub(1), vUv.y.add(1));
          const len2 = a.mul(a).add(b.mul(b));
          const dlen = property("float", "dlen");
          dlen.assign(len2.fwidth());
          If(vUv.y.abs().greaterThan(1), () => {
            alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());
          });
        } else {
          If(vUv.y.abs().greaterThan(1), () => {
            const a = vUv.x;
            const b = vUv.y.greaterThan(0).cond(vUv.y.sub(1), vUv.y.add(1));
            const len2 = a.mul(a).add(b.mul(b));
            len2.greaterThan(1).discard();
          });
        }
      }
      let lineColorNode;
      if (this.lineColorNode) {
        lineColorNode = this.lineColorNode;
      } else {
        if (useColor) {
          const instanceColorStart = attribute("instanceColorStart");
          const instanceColorEnd = attribute("instanceColorEnd");
          const instanceColor = positionGeometry.y.lessThan(0.5).cond(instanceColorStart, instanceColorEnd);
          lineColorNode = instanceColor.mul(materialColor);
        } else {
          lineColorNode = materialColor;
        }
      }
      return vec4(lineColorNode, alpha);
    })();
    this.needsUpdate = true;
  }
  get worldUnits() {
    return this.useWorldUnits;
  }
  set worldUnits(value) {
    if (this.useWorldUnits !== value) {
      this.useWorldUnits = value;
      this.setupShaders();
    }
  }
  get dashed() {
    return this.useDash;
  }
  set dashed(value) {
    if (this.useDash !== value) {
      this.useDash = value;
      this.setupShaders();
    }
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(value) {
    if (this.useAlphaToCoverage !== value) {
      this.useAlphaToCoverage = value;
      this.setupShaders();
    }
  }
};
var Line2NodeMaterial_default = Line2NodeMaterial;
addNodeMaterial("Line2NodeMaterial", Line2NodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshNormalNodeMaterial.js
var defaultValues5 = new MeshNormalMaterial();
var MeshNormalNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshNormalNodeMaterial = true;
    this.colorSpaced = false;
    this.setDefaultValues(defaultValues5);
    this.setValues(parameters);
  }
  setupDiffuseColor() {
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    diffuseColor.assign(vec4(directionToColor(transformedNormalView), opacityNode));
  }
};
var MeshNormalNodeMaterial_default = MeshNormalNodeMaterial;
addNodeMaterial("MeshNormalNodeMaterial", MeshNormalNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshBasicNodeMaterial.js
var defaultValues6 = new MeshBasicMaterial();
var MeshBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshBasicNodeMaterial = true;
    this.lights = false;
    this.setDefaultValues(defaultValues6);
    this.setValues(parameters);
  }
};
var MeshBasicNodeMaterial_default = MeshBasicNodeMaterial;
addNodeMaterial("MeshBasicNodeMaterial", MeshBasicNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/BSDF/F_Schlick.js
var F_Schlick = tslFn(({ f0, f90, dotVH }) => {
  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
});
var F_Schlick_default = F_Schlick;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Lambert.js
var BRDF_Lambert = tslFn((inputs) => {
  return inputs.diffuseColor.mul(1 / Math.PI);
});
var BRDF_Lambert_default = BRDF_Lambert;

// node_modules/three/examples/jsm/nodes/functions/PhongLightingModel.js
var G_BlinnPhong_Implicit = () => float(0.25);
var D_BlinnPhong = tslFn(({ dotNH }) => {
  return shininess.mul(0.5 / Math.PI).add(1).mul(dotNH.pow(shininess));
});
var BRDF_BlinnPhong = tslFn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNH = transformedNormalView.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  const F = F_Schlick_default({ f0: specularColor, f90: 1, dotVH });
  const G = G_BlinnPhong_Implicit();
  const D = D_BlinnPhong({ dotNH });
  return F.mul(G).mul(D);
});
var PhongLightingModel = class extends LightingModel_default {
  constructor(specular = true) {
    super();
    this.specular = specular;
  }
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = transformedNormalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor: diffuseColor.rgb })));
    if (this.specular === true) {
      reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({ lightDirection })).mul(materialSpecularStrength));
    }
  }
  indirectDiffuse({ irradiance, reflectedLight }) {
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor })));
  }
};
var PhongLightingModel_default = PhongLightingModel;

// node_modules/three/examples/jsm/nodes/materials/MeshLambertNodeMaterial.js
var defaultValues7 = new MeshLambertMaterial();
var MeshLambertNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshLambertNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(defaultValues7);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new PhongLightingModel_default(false);
  }
};
var MeshLambertNodeMaterial_default = MeshLambertNodeMaterial;
addNodeMaterial("MeshLambertNodeMaterial", MeshLambertNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshPhongNodeMaterial.js
var defaultValues8 = new MeshPhongMaterial();
var MeshPhongNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshPhongNodeMaterial = true;
    this.lights = true;
    this.shininessNode = null;
    this.specularNode = null;
    this.setDefaultValues(defaultValues8);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new PhongLightingModel_default();
  }
  setupVariants() {
    const shininessNode = (this.shininessNode ? float(this.shininessNode) : materialShininess).max(1e-4);
    shininess.assign(shininessNode);
    const specularNode = this.specularNode || materialSpecularColor;
    specularColor.assign(specularNode);
  }
  copy(source) {
    this.shininessNode = source.shininessNode;
    this.specularNode = source.specularNode;
    return super.copy(source);
  }
};
var MeshPhongNodeMaterial_default = MeshPhongNodeMaterial;
addNodeMaterial("MeshPhongNodeMaterial", MeshPhongNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/material/getGeometryRoughness.js
var getGeometryRoughness = tslFn(() => {
  const dxy = normalGeometry.dFdx().abs().max(normalGeometry.dFdy().abs());
  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);
  return geometryRoughness;
});
var getGeometryRoughness_default = getGeometryRoughness;

// node_modules/three/examples/jsm/nodes/functions/material/getRoughness.js
var getRoughness = tslFn((inputs) => {
  const { roughness: roughness2 } = inputs;
  const geometryRoughness = getGeometryRoughness_default();
  let roughnessFactor = roughness2.max(0.0525);
  roughnessFactor = roughnessFactor.add(geometryRoughness);
  roughnessFactor = roughnessFactor.min(1);
  return roughnessFactor;
});
var getRoughness_default = getRoughness;

// node_modules/three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated.js
var V_GGX_SmithCorrelated = tslFn((inputs) => {
  const { alpha, dotNL, dotNV } = inputs;
  const a2 = alpha.pow2();
  const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());
  const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());
  return div(0.5, gv.add(gl).max(EPSILON));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
});
var V_GGX_SmithCorrelated_default = V_GGX_SmithCorrelated;

// node_modules/three/examples/jsm/nodes/functions/BSDF/D_GGX.js
var D_GGX = tslFn(({ alpha, dotNH }) => {
  const a2 = alpha.pow2();
  const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus();
  return a2.div(denom.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
var D_GGX_default = D_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_GGX.js
var BRDF_GGX = tslFn((inputs) => {
  const { lightDirection, f0, f90, roughness: roughness2, iridescenceFresnel } = inputs;
  const normalView2 = inputs.normalView || transformedNormalView;
  const alpha = roughness2.pow2();
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = normalView2.dot(lightDirection).clamp();
  const dotNV = normalView2.dot(positionViewDirection).clamp();
  const dotNH = normalView2.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  let F = F_Schlick_default({ f0, f90, dotVH });
  if (iridescenceFresnel) {
    F = iridescence.mix(F, iridescenceFresnel);
  }
  const V = V_GGX_SmithCorrelated_default({ alpha, dotNL, dotNV });
  const D = D_GGX_default({ alpha, dotNH });
  return F.mul(V).mul(D);
});
var BRDF_GGX_default = BRDF_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/DFGApprox.js
var DFGApprox = tslFn(({ roughness: roughness2, dotNV }) => {
  const c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const c1 = vec4(1, 0.0425, 1.04, -0.04);
  const r = roughness2.mul(c0).add(c1);
  const a004 = r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);
  const fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);
  return fab;
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" }
  ]
});
var DFGApprox_default = DFGApprox;

// node_modules/three/examples/jsm/nodes/functions/BSDF/EnvironmentBRDF.js
var EnvironmentBRDF = tslFn((inputs) => {
  const { dotNV, specularColor: specularColor2, specularF90, roughness: roughness2 } = inputs;
  const fab = DFGApprox_default({ dotNV, roughness: roughness2 });
  return specularColor2.mul(fab.x).add(specularF90.mul(fab.y));
});
var EnvironmentBRDF_default = EnvironmentBRDF;

// node_modules/three/examples/jsm/nodes/functions/BSDF/Schlick_to_F0.js
var Schlick_to_F0 = tslFn(({ f, f90, dotVH }) => {
  const x = dotVH.oneMinus().saturate();
  const x2 = x.mul(x);
  const x5 = x.mul(x2, x2).clamp(0, 0.9999);
  return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
});
var Schlick_to_F0_default = Schlick_to_F0;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Sheen.js
var D_Charlie = tslFn(({ roughness: roughness2, dotNH }) => {
  const alpha = roughness2.pow2();
  const invAlpha = float(1).div(alpha);
  const cos2h = dotNH.pow2();
  const sin2h = cos2h.oneMinus().max(78125e-7);
  return float(2).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
var V_Neubelt = tslFn(({ dotNV, dotNL }) => {
  return float(1).div(float(4).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));
}).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
});
var BRDF_Sheen = tslFn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = transformedNormalView.dot(lightDirection).clamp();
  const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
  const dotNH = transformedNormalView.dot(halfDir).clamp();
  const D = D_Charlie({ roughness: sheenRoughness, dotNH });
  const V = V_Neubelt({ dotNV, dotNL });
  return sheen.mul(D).mul(V);
});
var BRDF_Sheen_default = BRDF_Sheen;

// node_modules/three/examples/jsm/nodes/functions/PhysicalLightingModel.js
var XYZ_TO_REC709 = mat3(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
);
var Fresnel0ToIor = (fresnel0) => {
  const sqrtF0 = fresnel0.sqrt();
  return vec3(1).add(sqrtF0).div(vec3(1).sub(sqrtF0));
};
var IorToFresnel0 = (transmittedIor, incidentIor) => {
  return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();
};
var evalSensitivity = (OPD, shift) => {
  const phase = OPD.mul(2 * Math.PI * 1e-9);
  const val = vec3(54856e-17, 44201e-17, 52481e-17);
  const pos = vec3(1681e3, 1795300, 2208400);
  const VAR = vec3(43278e5, 93046e5, 66121e5);
  const x = float(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(phase.mul(2239900).add(shift.x).cos()).mul(phase.pow2().mul(-45282e5).exp());
  let xyz = val.mul(VAR.mul(2 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());
  xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(10685e-11);
  const rgb = XYZ_TO_REC709.mul(xyz);
  return rgb;
};
var evalIridescence = tslFn(({ outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 }) => {
  const iridescenceIOR2 = mix(outsideIOR, eta2, smoothstep(0, 0.03, thinFilmThickness));
  const sinTheta2Sq = outsideIOR.div(iridescenceIOR2).pow2().mul(float(1).sub(cosTheta1.pow2()));
  const cosTheta2Sq = float(1).sub(sinTheta2Sq);
  const cosTheta2 = cosTheta2Sq.sqrt();
  const R0 = IorToFresnel0(iridescenceIOR2, outsideIOR);
  const R12 = F_Schlick_default({ f0: R0, f90: 1, dotVH: cosTheta1 });
  const T121 = R12.oneMinus();
  const phi12 = iridescenceIOR2.lessThan(outsideIOR).cond(Math.PI, 0);
  const phi21 = float(Math.PI).sub(phi12);
  const baseIOR = Fresnel0ToIor(baseF0.clamp(0, 0.9999));
  const R1 = IorToFresnel0(baseIOR, iridescenceIOR2.vec3());
  const R23 = F_Schlick_default({ f0: R1, f90: 1, dotVH: cosTheta2 });
  const phi23 = vec3(
    baseIOR.x.lessThan(iridescenceIOR2).cond(Math.PI, 0),
    baseIOR.y.lessThan(iridescenceIOR2).cond(Math.PI, 0),
    baseIOR.z.lessThan(iridescenceIOR2).cond(Math.PI, 0)
  );
  const OPD = iridescenceIOR2.mul(thinFilmThickness, cosTheta2, 2);
  const phi = vec3(phi21).add(phi23);
  const R123 = R12.mul(R23).clamp(1e-5, 0.9999);
  const r123 = R123.sqrt();
  const Rs = T121.pow2().mul(R23).div(vec3(1).sub(R123));
  const C0 = R12.add(Rs);
  let I = C0;
  let Cm = Rs.sub(T121);
  for (let m = 1; m <= 2; ++m) {
    Cm = Cm.mul(r123);
    const Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2);
    I = I.add(Cm.mul(Sm));
  }
  return I.max(vec3(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
});
var IBLSheenBRDF = tslFn(({ normal, viewDir, roughness: roughness2 }) => {
  const dotNV = normal.dot(viewDir).saturate();
  const r2 = roughness2.pow2();
  const a = cond(
    roughness2.lessThan(0.25),
    float(-339.2).mul(r2).add(float(161.4).mul(roughness2)).sub(25.9),
    float(-8.48).mul(r2).add(float(14.3).mul(roughness2)).sub(9.95)
  );
  const b = cond(
    roughness2.lessThan(0.25),
    float(44).mul(r2).sub(float(23.7).mul(roughness2)).add(3.26),
    float(1.97).mul(r2).sub(float(3.27).mul(roughness2)).add(0.72)
  );
  const DG = cond(roughness2.lessThan(0.25), 0, float(0.1).mul(roughness2).sub(0.025)).add(a.mul(dotNV).add(b).exp());
  return DG.mul(1 / Math.PI).saturate();
});
var clearcoatF0 = vec3(0.04);
var clearcoatF90 = vec3(1);
var PhysicalLightingModel = class extends LightingModel_default {
  constructor(clearcoat2 = false, sheen2 = false, iridescence2 = false) {
    super();
    this.clearcoat = clearcoat2;
    this.sheen = sheen2;
    this.iridescence = iridescence2;
    this.clearcoatRadiance = null;
    this.clearcoatSpecularDirect = null;
    this.clearcoatSpecularIndirect = null;
    this.sheenSpecularDirect = null;
    this.sheenSpecularIndirect = null;
    this.iridescenceFresnel = null;
    this.iridescenceF0 = null;
  }
  start() {
    if (this.clearcoat === true) {
      this.clearcoatRadiance = vec3().temp("clearcoatRadiance");
      this.clearcoatSpecularDirect = vec3().temp("clearcoatSpecularDirect");
      this.clearcoatSpecularIndirect = vec3().temp("clearcoatSpecularIndirect");
    }
    if (this.sheen === true) {
      this.sheenSpecularDirect = vec3().temp("sheenSpecularDirect");
      this.sheenSpecularIndirect = vec3().temp("sheenSpecularIndirect");
    }
    if (this.iridescence === true) {
      const dotNVi = transformedNormalView.dot(positionViewDirection).clamp();
      this.iridescenceFresnel = evalIridescence({
        outsideIOR: float(1),
        eta2: iridescenceIOR,
        cosTheta1: dotNVi,
        thinFilmThickness: iridescenceThickness,
        baseF0: specularColor
      });
      this.iridescenceF0 = Schlick_to_F0_default({ f: this.iridescenceFresnel, f90: 1, dotVH: dotNVi });
    }
  }
  // Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multiscattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(singleScatter, multiScatter, specularF90 = float(1)) {
    const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
    const fab = DFGApprox_default({ roughness, dotNV });
    const Fr = this.iridescenceF0 ? iridescence.mix(specularColor, this.iridescenceF0) : specularColor;
    const FssEss = Fr.mul(fab.x).add(specularF90.mul(fab.y));
    const Ess = fab.x.add(fab.y);
    const Ems = Ess.oneMinus();
    const Favg = specularColor.add(specularColor.oneMinus().mul(0.047619));
    const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());
    singleScatter.addAssign(FssEss);
    multiScatter.addAssign(Fms.mul(Ems));
  }
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = transformedNormalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    if (this.sheen === true) {
      this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen_default({ lightDirection })));
    }
    if (this.clearcoat === true) {
      const dotNLcc = transformedClearcoatNormalView.dot(lightDirection).clamp();
      const ccIrradiance = dotNLcc.mul(lightColor);
      this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX_default({ lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView })));
    }
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor: diffuseColor.rgb })));
    reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX_default({ lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, iridescenceFresnel: this.iridescenceFresnel })));
  }
  indirectDiffuse({ irradiance, reflectedLight }) {
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor })));
  }
  indirectSpecular({ radiance, iblIrradiance, reflectedLight }) {
    if (this.sheen === true) {
      this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(
        sheen,
        IBLSheenBRDF({
          normal: transformedNormalView,
          viewDir: positionViewDirection,
          roughness: sheenRoughness
        })
      ));
    }
    if (this.clearcoat === true) {
      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();
      const clearcoatEnv = EnvironmentBRDF_default({
        dotNV: dotNVcc,
        specularColor: clearcoatF0,
        specularF90: clearcoatF90,
        roughness: clearcoatRoughness
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));
    }
    const singleScattering = vec3().temp("singleScattering");
    const multiScattering = vec3().temp("multiScattering");
    const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);
    this.computeMultiscattering(singleScattering, multiScattering);
    const totalScattering = singleScattering.add(multiScattering);
    const diffuse = diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());
    reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));
    reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));
    reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));
  }
  ambientOcclusion({ ambientOcclusion, reflectedLight }) {
    const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
    const aoNV = dotNV.add(ambientOcclusion);
    const aoExp = roughness.mul(-16).oneMinus().negate().exp2();
    const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();
    if (this.clearcoat === true) {
      this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion);
    }
    if (this.sheen === true) {
      this.sheenSpecularIndirect.mulAssign(ambientOcclusion);
    }
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
    reflectedLight.indirectSpecular.mulAssign(aoNode);
  }
  finish(context2) {
    const { outgoingLight } = context2;
    if (this.clearcoat === true) {
      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();
      const Fcc = F_Schlick_default({
        dotVH: dotNVcc,
        f0: clearcoatF0,
        f90: clearcoatF90
      });
      const clearcoatLight = outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDirect, this.clearcoatSpecularIndirect).mul(clearcoat);
      outgoingLight.assign(clearcoatLight);
    }
    if (this.sheen === true) {
      const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(0.157).oneMinus();
      const sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      outgoingLight.assign(sheenLight);
    }
  }
};
var PhysicalLightingModel_default = PhysicalLightingModel;

// node_modules/three/examples/jsm/nodes/materials/MeshStandardNodeMaterial.js
var defaultValues9 = new MeshStandardMaterial();
var MeshStandardNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshStandardNodeMaterial = true;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.setDefaultValues(defaultValues9);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new PhysicalLightingModel_default();
  }
  setupVariants() {
    const metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;
    metalness.assign(metalnessNode);
    let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;
    roughnessNode = getRoughness_default({ roughness: roughnessNode });
    roughness.assign(roughnessNode);
    const specularColorNode = mix(vec3(0.04), diffuseColor.rgb, metalnessNode);
    specularColor.assign(specularColorNode);
    diffuseColor.assign(vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), diffuseColor.a));
  }
  copy(source) {
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    return super.copy(source);
  }
};
var MeshStandardNodeMaterial_default = MeshStandardNodeMaterial;
addNodeMaterial("MeshStandardNodeMaterial", MeshStandardNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshPhysicalNodeMaterial.js
var defaultValues10 = new MeshPhysicalMaterial();
var MeshPhysicalNodeMaterial = class extends MeshStandardNodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshPhysicalNodeMaterial = true;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.clearcoatNormalNode = null;
    this.sheenNode = null;
    this.sheenRoughnessNode = null;
    this.iridescenceNode = null;
    this.iridescenceIORNode = null;
    this.iridescenceThicknessNode = null;
    this.specularIntensityNode = null;
    this.specularColorNode = null;
    this.transmissionNode = null;
    this.thicknessNode = null;
    this.attenuationDistanceNode = null;
    this.attenuationColorNode = null;
    this.setDefaultValues(defaultValues10);
    this.setValues(parameters);
  }
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  setupLightingModel() {
    return new PhysicalLightingModel_default(this.useClearcoat, this.useSheen, this.useIridescence);
  }
  setupVariants(builder) {
    super.setupVariants(builder);
    if (this.useClearcoat) {
      const clearcoatNode = this.clearcoatNode ? float(this.clearcoatNode) : materialClearcoat;
      const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float(this.clearcoatRoughnessNode) : materialClearcoatRoughness;
      clearcoat.assign(clearcoatNode);
      clearcoatRoughness.assign(clearcoatRoughnessNode);
    }
    if (this.useSheen) {
      const sheenNode = this.sheenNode ? vec3(this.sheenNode) : materialSheen;
      const sheenRoughnessNode = this.sheenRoughnessNode ? float(this.sheenRoughnessNode) : materialSheenRoughness;
      sheen.assign(sheenNode);
      sheenRoughness.assign(sheenRoughnessNode);
    }
    if (this.useIridescence) {
      const iridescenceNode = this.iridescenceNode ? float(this.iridescenceNode) : materialIridescence;
      const iridescenceIORNode = this.iridescenceIORNode ? float(this.iridescenceIORNode) : materialIridescenceIOR;
      const iridescenceThicknessNode = this.iridescenceThicknessNode ? float(this.iridescenceThicknessNode) : materialIridescenceThickness;
      iridescence.assign(iridescenceNode);
      iridescenceIOR.assign(iridescenceIORNode);
      iridescenceThickness.assign(iridescenceThicknessNode);
    }
  }
  setupNormal(builder) {
    super.setupNormal(builder);
    const clearcoatNormalNode = this.clearcoatNormalNode ? vec3(this.clearcoatNormalNode) : materialClearcoatNormal;
    transformedClearcoatNormalView.assign(clearcoatNormalNode);
  }
  copy(source) {
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.clearcoatNormalNode = source.clearcoatNormalNode;
    this.sheenNode = source.sheenNode;
    this.sheenRoughnessNode = source.sheenRoughnessNode;
    this.iridescenceNode = source.iridescenceNode;
    this.iridescenceIORNode = source.iridescenceIORNode;
    this.iridescenceThicknessNode = source.iridescenceThicknessNode;
    this.specularIntensityNode = source.specularIntensityNode;
    this.specularColorNode = source.specularColorNode;
    this.transmissionNode = source.transmissionNode;
    this.thicknessNode = source.thicknessNode;
    this.attenuationDistanceNode = source.attenuationDistanceNode;
    this.attenuationColorNode = source.attenuationColorNode;
    return super.copy(source);
  }
};
var MeshPhysicalNodeMaterial_default = MeshPhysicalNodeMaterial;
addNodeMaterial("MeshPhysicalNodeMaterial", MeshPhysicalNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/PointsNodeMaterial.js
var defaultValues11 = new PointsMaterial();
var PointsNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isPointsNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.transparent = true;
    this.sizeNode = null;
    this.setDefaultValues(defaultValues11);
    this.setValues(parameters);
  }
  copy(source) {
    this.sizeNode = source.sizeNode;
    return super.copy(source);
  }
};
var PointsNodeMaterial_default = PointsNodeMaterial;
addNodeMaterial("PointsNodeMaterial", PointsNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/SpriteNodeMaterial.js
var defaultValues12 = new SpriteMaterial();
var SpriteNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isSpriteNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.positionNode = null;
    this.rotationNode = null;
    this.scaleNode = null;
    this.setDefaultValues(defaultValues12);
    this.setValues(parameters);
  }
  setupPosition({ object, context: context2 }) {
    const { positionNode, rotationNode, scaleNode } = this;
    const vertex = positionLocal;
    let mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));
    let scale = vec2(modelWorldMatrix[0].xyz.length(), modelWorldMatrix[1].xyz.length());
    if (scaleNode !== null) {
      scale = scale.mul(scaleNode);
    }
    let alignedPosition = vertex.xy;
    if (object.center && object.center.isVector2 === true) {
      alignedPosition = alignedPosition.sub(uniform(object.center).sub(0.5));
    }
    alignedPosition = alignedPosition.mul(scale);
    const rotation = float(rotationNode || materialRotation);
    const cosAngle = rotation.cos();
    const sinAngle = rotation.sin();
    const rotatedPosition = vec2(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( alignedPosition )?
      vec2(cosAngle, sinAngle.negate()).dot(alignedPosition),
      vec2(sinAngle, cosAngle).dot(alignedPosition)
    );
    mvPosition = vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);
    const modelViewProjection2 = cameraProjectionMatrix.mul(mvPosition);
    context2.vertex = vertex;
    return modelViewProjection2;
  }
  copy(source) {
    this.positionNode = source.positionNode;
    this.rotationNode = source.rotationNode;
    this.scaleNode = source.scaleNode;
    return super.copy(source);
  }
};
var SpriteNodeMaterial_default = SpriteNodeMaterial;
addNodeMaterial("SpriteNodeMaterial", SpriteNodeMaterial);

// node_modules/three/examples/jsm/nodes/loaders/NodeMaterialLoader.js
var superFromTypeFunction = MaterialLoader.createMaterialFromType;
MaterialLoader.createMaterialFromType = function(type) {
  const material = createNodeMaterialFromType(type);
  if (material !== void 0) {
    return material;
  }
  return superFromTypeFunction.call(this, type);
};
var NodeMaterialLoader = class extends MaterialLoader {
  constructor(manager) {
    super(manager);
    this.nodes = {};
  }
  parse(json) {
    const material = super.parse(json);
    const nodes = this.nodes;
    const inputNodes = json.inputNodes;
    for (const property2 in inputNodes) {
      const uuid = inputNodes[property2];
      material[property2] = nodes[uuid];
    }
    return material;
  }
  setNodes(value) {
    this.nodes = value;
    return this;
  }
};
var NodeMaterialLoader_default = NodeMaterialLoader;

// node_modules/three/examples/jsm/nodes/loaders/NodeObjectLoader.js
var NodeObjectLoader = class extends ObjectLoader {
  constructor(manager) {
    super(manager);
    this._nodesJSON = null;
  }
  parse(json, onLoad) {
    this._nodesJSON = json.nodes;
    const data = super.parse(json, onLoad);
    this._nodesJSON = null;
    return data;
  }
  parseNodes(json, textures) {
    if (json !== void 0) {
      const loader = new NodeLoader_default();
      loader.setTextures(textures);
      return loader.parseNodes(json);
    }
    return {};
  }
  parseMaterials(json, textures) {
    const materials = {};
    if (json !== void 0) {
      const nodes = this.parseNodes(this._nodesJSON, textures);
      const loader = new NodeMaterialLoader_default();
      loader.setTextures(textures);
      loader.setNodes(nodes);
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        materials[data.uuid] = loader.parse(data);
      }
    }
    return materials;
  }
};
var NodeObjectLoader_default = NodeObjectLoader;

// node_modules/three/examples/jsm/nodes/core/NodeParser.js
var NodeParser = class {
  parseFunction() {
    console.warn("Abstract function.");
  }
};
var NodeParser_default = NodeParser;

// node_modules/three/examples/jsm/nodes/core/NodeFunction.js
var NodeFunction = class {
  constructor(type, inputs, name = "", presicion = "") {
    this.type = type;
    this.inputs = inputs;
    this.name = name;
    this.presicion = presicion;
  }
  getCode() {
    console.warn("Abstract function.");
  }
};
NodeFunction.isNodeFunction = true;
var NodeFunction_default = NodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/GLSLNodeFunction.js
var declarationRegexp = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
var propertiesRegexp = /[a-z_0-9]+/ig;
var pragmaMain = "#pragma main";
var parse = (source) => {
  source = source.trim();
  const pragmaMainIndex = source.indexOf(pragmaMain);
  const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;
  const declaration = mainCode.match(declarationRegexp);
  if (declaration !== null && declaration.length === 5) {
    const inputsCode = declaration[4];
    const propsMatches = [];
    let nameMatch = null;
    while ((nameMatch = propertiesRegexp.exec(inputsCode)) !== null) {
      propsMatches.push(nameMatch);
    }
    const inputs = [];
    let i = 0;
    while (i < propsMatches.length) {
      const isConst = propsMatches[i][0] === "const";
      if (isConst === true) {
        i++;
      }
      let qualifier = propsMatches[i][0];
      if (qualifier === "in" || qualifier === "out" || qualifier === "inout") {
        i++;
      } else {
        qualifier = "";
      }
      const type2 = propsMatches[i++][0];
      let count = Number.parseInt(propsMatches[i][0]);
      if (Number.isNaN(count) === false)
        i++;
      else
        count = null;
      const name2 = propsMatches[i++][0];
      inputs.push(new NodeFunctionInput_default(type2, name2, count, qualifier, isConst));
    }
    const blockCode = mainCode.substring(declaration[0].length);
    const name = declaration[3] !== void 0 ? declaration[3] : "";
    const type = declaration[2];
    const presicion = declaration[1] !== void 0 ? declaration[1] : "";
    const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : "";
    return {
      type,
      inputs,
      name,
      presicion,
      inputsCode,
      blockCode,
      headerCode
    };
  } else {
    throw new Error("FunctionNode: Function is not a GLSL code.");
  }
};
var GLSLNodeFunction = class extends NodeFunction_default {
  constructor(source) {
    const { type, inputs, name, presicion, inputsCode, blockCode, headerCode } = parse(source);
    super(type, inputs, name, presicion);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
    this.headerCode = headerCode;
  }
  getCode(name = this.name) {
    let code2;
    const blockCode = this.blockCode;
    if (blockCode !== "") {
      const { type, inputsCode, headerCode, presicion } = this;
      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;
      if (presicion !== "") {
        declarationCode = `${presicion} ${declarationCode}`;
      }
      code2 = headerCode + declarationCode + blockCode;
    } else {
      code2 = "";
    }
    return code2;
  }
};
var GLSLNodeFunction_default = GLSLNodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/GLSLNodeParser.js
var GLSLNodeParser = class extends NodeParser_default {
  parseFunction(source) {
    return new GLSLNodeFunction_default(source);
  }
};
var GLSLNodeParser_default = GLSLNodeParser;

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_noise.js
var mx_noise = glsl(`float mx_select(bool b, float t, float f)
{
    return b ? t : f;
}

float mx_negate_if(float val, bool b)
{
    return b ? -val : val;
}

int mx_floor(float x)
{
    return int(floor(x));
}

// return mx_floor as well as the fractional remainder
float mx_floorfrac(float x, out int i)
{
    i = mx_floor(x);
    return x - float(i);
}

float mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
vec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
float mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}
vec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}

// 2 and 3 dimensional gradient functions - perform a dot product against a
// randomly chosen vector. Note that the gradient vector is not normalized, but
// this only affects the overal "scale" of the result, so we simply account for
// the scale by multiplying in the corresponding "perlin" function.
float mx_gradient_float(uint hash, float x, float y)
{
    // 8 possible directions (+-1,+-2) and (+-2,+-1)
    uint h = hash & 7u;
    float u = mx_select(h<4u, x, y);
    float v = 2.0 * mx_select(h<4u, y, x);
    // compute the dot product with (x,y).
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
float mx_gradient_float(uint hash, float x, float y, float z)
{
    // use vectors pointing to the edges of the cube
    uint h = hash & 15u;
    float u = mx_select(h<8u, x, y);
    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y)
{
    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)
{
    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
}
// Scaling factors to normalize the result of gradients above.
// These factors were experimentally calculated to be:
//    2D:   0.6616
//    3D:   0.9820
float mx_gradient_scale2d(float v) { return 0.6616 * v; }
float mx_gradient_scale3d(float v) { return 0.9820 * v; }
vec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }
vec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }

/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)
uint mx_rotl32(uint x, int k)
{
    return (x<<k) | (x>>(32-k));
}

void mx_bjmix(inout uint a, inout uint b, inout uint c)
{
    a -= c; a ^= mx_rotl32(c, 4); c += b;
    b -= a; b ^= mx_rotl32(a, 6); a += c;
    c -= b; c ^= mx_rotl32(b, 8); b += a;
    a -= c; a ^= mx_rotl32(c,16); c += b;
    b -= a; b ^= mx_rotl32(a,19); a += c;
    c -= b; c ^= mx_rotl32(b, 4); b += a;
}

// Mix up and combine the bits of a, b, and c (doesn't change them, but
// returns a hash of those three original values).
uint mx_bjfinal(uint a, uint b, uint c)
{
    c ^= b; c -= mx_rotl32(b,14);
    a ^= c; a -= mx_rotl32(c,11);
    b ^= a; b -= mx_rotl32(a,25);
    c ^= b; c -= mx_rotl32(b,16);
    a ^= c; a -= mx_rotl32(c,4);
    b ^= a; b -= mx_rotl32(a,14);
    c ^= b; c -= mx_rotl32(b,24);
    return c;
}

// Convert a 32 bit integer into a floating point number in [0,1]
float mx_bits_to_01(uint bits)
{
    return float(bits) / float(uint(0xffffffff));
}

float mx_fade(float t)
{
   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

uint mx_hash_int(int x)
{
    uint len = 1u;
    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;
    return mx_bjfinal(seed+uint(x), seed, seed);
}

uint mx_hash_int(int x, int y)
{
    uint len = 2u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z)
{
    uint len = 3u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx)
{
    uint len = 4u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx, int yy)
{
    uint len = 5u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    b += uint(yy);
    return mx_bjfinal(a, b, c);
}

uvec3 mx_hash_vec3(int x, int y)
{
    uint h = mx_hash_int(x, y);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

uvec3 mx_hash_vec3(int x, int y, int z)
{
    uint h = mx_hash_int(x, y, z);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

float mx_perlin_noise_float(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float result = mx_bilerp(
        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),
        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

float mx_perlin_noise_float(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    float result = mx_trilerp(
        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

vec3 mx_perlin_noise_vec3(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    vec3 result = mx_bilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

vec3 mx_perlin_noise_vec3(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    vec3 result = mx_trilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

float mx_cell_noise_float(float p)
{
    int ix = mx_floor(p);
    return mx_bits_to_01(mx_hash_int(ix));
}

float mx_cell_noise_float(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return mx_bits_to_01(mx_hash_int(ix, iy));
}

float mx_cell_noise_float(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}

float mx_cell_noise_float(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}

vec3 mx_cell_noise_vec3(float p)
{
    int ix = mx_floor(p);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, 0)),
            mx_bits_to_01(mx_hash_int(ix, 1)),
            mx_bits_to_01(mx_hash_int(ix, 2))
    );
}

vec3 mx_cell_noise_vec3(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, 2))
    );
}

vec3 mx_cell_noise_vec3(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))
    );
}

vec3 mx_cell_noise_vec3(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))
    );
}

float mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)
{
    float result = 0.0;
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_float(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3 result = vec3(0.0);
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_vec3(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)
{
    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),
                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));
}

vec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);
    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);
    return vec4(c, f);
}

float mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)
{
    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));
    vec2  off = vec2(tmp.x, tmp.y);

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec2 cellpos = vec2(float(x), float(y)) + off;
    vec2 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y);       // Manhattan distance
    if (metric == 3)
        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)
{
    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;
    vec3 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance
    if (metric == 3)
        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_noise_float(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            sqdist = min(sqdist, dist);
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.y = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.z = sqdist.y;
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.z = sqdist.y;
                sqdist.y = dist;
            }
            else if (dist < sqdist.z)
            {
                sqdist.z = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

float mx_worley_noise_float(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    float sqdist = 1e6f;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                sqdist = min(sqdist, dist);
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.y = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = dist;
                }
                else if (dist < sqdist.z)
                {
                    sqdist.z = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}`);
var includes = [mx_noise];
var mx_perlin_noise_float = glslFn("float mx_perlin_noise_float( any p )", includes);
var mx_perlin_noise_vec2 = glslFn("vec2 mx_perlin_noise_vec2( any p )", includes);
var mx_perlin_noise_vec3 = glslFn("vec3 mx_perlin_noise_vec3( any p )", includes);
var mx_cell_noise_float = glslFn("float mx_cell_noise_float( vec3 p )", includes);
var mx_worley_noise_float = glslFn("float mx_worley_noise_float( any p, float jitter, int metric )", includes);
var mx_worley_noise_vec2 = glslFn("vec2 mx_worley_noise_vec2( any p, float jitter, int metric )", includes);
var mx_worley_noise_vec3 = glslFn("vec3 mx_worley_noise_vec3( any p, float jitter, int metric )", includes);
var mx_fractal_noise_float = glslFn("float mx_fractal_noise_float( vec3 p, int octaves, float lacunarity, float diminish )", includes);
var mx_fractal_noise_vec2 = glslFn("vec2 mx_fractal_noise_vec2( vec3 p, int octaves, float lacunarity, float diminish )", includes);
var mx_fractal_noise_vec3 = glslFn("vec3 mx_fractal_noise_vec3( vec3 p, int octaves, float lacunarity, float diminish )", includes);
var mx_fractal_noise_vec4 = glslFn("vec4 mx_fractal_noise_vec4( vec3 p, int octaves, float lacunarity, float diminish )", includes);

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_hsv.js
var mx_hsvtorgb = glslFn(`vec3 mx_hsvtorgb(vec3 hsv)
{
    // Reference for this technique: Foley & van Dam
    float h = hsv.x; float s = hsv.y; float v = hsv.z;
    if (s < 0.0001f) {
      return vec3 (v, v, v);
    } else {
        h = 6.0f * (h - floor(h));  // expand to [0..6)
        int hi = int(trunc(h));
        float f = h - float(hi);
        float p = v * (1.0f-s);
        float q = v * (1.0f-s*f);
        float t = v * (1.0f-s*(1.0f-f));
        if (hi == 0)
            return vec3 (v, t, p);
        else if (hi == 1)
            return vec3 (q, v, p);
        else if (hi == 2)
            return vec3 (p, v, t);
        else if (hi == 3)
            return vec3 (p, q, v);
        else if (hi == 4)
            return vec3 (t, p, v);
        return vec3 (v, p, q);
    }
}`);
var mx_rgbtohsv = glslFn(`vec3 mx_rgbtohsv(vec3 c)
{
    // See Foley & van Dam
    float r = c.x; float g = c.y; float b = c.z;
    float mincomp = min (r, min(g, b));
    float maxcomp = max (r, max(g, b));
    float delta = maxcomp - mincomp;  // chroma
    float h, s, v;
    v = maxcomp;
    if (maxcomp > 0.0f)
        s = delta / maxcomp;
    else s = 0.0f;
    if (s <= 0.0f)
        h = 0.0f;
    else {
        if      (r >= maxcomp) h = (g-b) / delta;
        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;
        else                   h = 4.0f + (r-g) / delta;
        h *= (1.0f/6.0f);
        if (h < 0.0f)
            h += 1.0f;
    }
    return vec3(h, s, v);
}`);

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_transform_color.js
var mx_transform_color = glsl(`#define M_AP1_TO_REC709 mat3(1.705079555511475, -0.1297005265951157, -0.02416634373366833, -0.6242334842681885, 1.138468623161316, -0.1246141716837883, -0.0808461606502533, -0.008768022060394287, 1.148780584335327)

vec3 mx_srgb_texture_to_lin_rec709(vec3 color)
{
    bvec3 isAbove = greaterThan(color, vec3(0.04045));
    vec3 linSeg = color / 12.92;
    vec3 powSeg = pow(max(color + vec3(0.055), vec3(0.0)) / 1.055, vec3(2.4));
    return mix(linSeg, powSeg, isAbove);
}`);
var includes2 = [mx_transform_color];
var mx_srgb_texture_to_lin_rec709 = glslFn("vec3 mx_srgb_texture_to_lin_rec709( vec3 color )", includes2);

// node_modules/three/examples/jsm/nodes/materialx/MaterialXNodes.js
var mx_aastep = (threshold, value) => {
  threshold = float(threshold);
  value = float(value);
  const afwidth = vec2(value.dFdx(), value.dFdy()).length().mul(0.7071067811865476);
  return smoothstep(threshold.sub(afwidth), threshold.add(afwidth), value);
};
var _ramp = (a, b, uv2, p) => mix(a, b, uv2[p].clamp());
var mx_ramplr = (valuel, valuer, texcoord = uv()) => _ramp(valuel, valuer, texcoord, "x");
var mx_ramptb = (valuet, valueb, texcoord = uv()) => _ramp(valuet, valueb, texcoord, "y");
var _split = (a, b, center, uv2, p) => mix(a, b, mx_aastep(center, uv2[p]));
var mx_splitlr = (valuel, valuer, center, texcoord = uv()) => _split(valuel, valuer, center, texcoord, "x");
var mx_splittb = (valuet, valueb, center, texcoord = uv()) => _split(valuet, valueb, center, texcoord, "y");
var mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv()) => uv_geo.mul(uv_scale).add(uv_offset);
var mx_safepower = (in1, in2 = 1) => {
  in1 = float(in1);
  return in1.abs().pow(in2).mul(in1.sign());
};
var mx_contrast = (input, amount = 1, pivot = 0.5) => float(input).sub(pivot).mul(amount).add(pivot);
var mx_noise_float = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_float(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec2 = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec2(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec3 = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec3(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec4 = (texcoord = uv(), amplitude = 1, pivot = 0) => {
  texcoord = texcoord.convert("vec2|vec3");
  const noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2(19, 73))));
  return noise_vec4.mul(amplitude).add(pivot);
};
var mx_worley_noise_float2 = (texcoord = uv(), jitter = 1) => mx_worley_noise_float(texcoord.convert("vec2|vec3"), jitter, 1);
var mx_worley_noise_vec22 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec2(texcoord.convert("vec2|vec3"), jitter, 1);
var mx_worley_noise_vec32 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec3(texcoord.convert("vec2|vec3"), jitter, 1);
var mx_cell_noise_float2 = (texcoord = uv()) => mx_cell_noise_float(texcoord.convert("vec2|vec3"));
var mx_fractal_noise_float2 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_float(position, octaves, lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec22 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec2(position, octaves, lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec32 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec3(position, octaves, lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec42 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec4(position, octaves, lacunarity, diminish).mul(amplitude);
export {
  AONode_default as AONode,
  AmbientLightNode_default as AmbientLightNode,
  AnalyticLightNode_default as AnalyticLightNode,
  ArrayElementNode_default as ArrayElementNode,
  ArrayUniformNode_default as ArrayUniformNode,
  AssignNode_default as AssignNode,
  AttributeNode_default as AttributeNode,
  BRDF_GGX_default as BRDF_GGX,
  BRDF_Lambert_default as BRDF_Lambert,
  BitangentNode_default as BitangentNode,
  BlendModeNode_default as BlendModeNode,
  BufferAttributeNode_default as BufferAttributeNode,
  BufferNode_default as BufferNode,
  BumpMapNode_default as BumpMapNode,
  BypassNode_default as BypassNode,
  CacheNode_default as CacheNode,
  CameraNode_default as CameraNode,
  CheckerNode_default as CheckerNode,
  CodeNode_default as CodeNode,
  ColorAdjustmentNode_default as ColorAdjustmentNode,
  ColorSpaceNode_default as ColorSpaceNode,
  ComputeNode_default as ComputeNode,
  CondNode_default as CondNode,
  ConstNode_default as ConstNode,
  ContextNode_default as ContextNode,
  ConvertNode_default as ConvertNode,
  CubeTextureNode_default as CubeTextureNode,
  DFGApprox_default as DFGApprox,
  D_GGX_default as D_GGX,
  DirectionalLightNode_default as DirectionalLightNode,
  DiscardNode_default as DiscardNode,
  EPSILON,
  EnvironmentNode_default as EnvironmentNode,
  EquirectUVNode_default as EquirectUVNode,
  ExpressionNode_default as ExpressionNode,
  F_Schlick_default as F_Schlick,
  FogExp2Node_default as FogExp2Node,
  FogNode_default as FogNode,
  FogRangeNode_default as FogRangeNode,
  FrontFacingNode_default as FrontFacingNode,
  FunctionCallNode_default as FunctionCallNode,
  FunctionNode_default as FunctionNode,
  GLSLNodeParser_default as GLSLNodeParser,
  HashNode_default as HashNode,
  HemisphereLightNode_default as HemisphereLightNode,
  IESSpotLightNode_default as IESSpotLightNode,
  INFINITY,
  If,
  IndexNode_default as IndexNode,
  InstanceNode_default as InstanceNode,
  InstancedPointsNodeMaterial_default as InstancedPointsNodeMaterial,
  JoinNode_default as JoinNode,
  LightNode_default as LightNode,
  LightingContextNode_default as LightingContextNode,
  LightingModel_default as LightingModel,
  LightingNode_default as LightingNode,
  LightsNode_default as LightsNode,
  Line2NodeMaterial_default as Line2NodeMaterial,
  LineBasicNodeMaterial_default as LineBasicNodeMaterial,
  LineDashedNodeMaterial_default as LineDashedNodeMaterial,
  LoopNode_default as LoopNode,
  MatcapUVNode_default as MatcapUVNode,
  MaterialNode_default as MaterialNode,
  MaterialReferenceNode_default as MaterialReferenceNode,
  MathNode_default as MathNode,
  MaxMipLevelNode_default as MaxMipLevelNode,
  MeshBasicNodeMaterial_default as MeshBasicNodeMaterial,
  MeshLambertNodeMaterial_default as MeshLambertNodeMaterial,
  MeshNormalNodeMaterial_default as MeshNormalNodeMaterial,
  MeshPhongNodeMaterial_default as MeshPhongNodeMaterial,
  MeshPhysicalNodeMaterial_default as MeshPhysicalNodeMaterial,
  MeshStandardNodeMaterial_default as MeshStandardNodeMaterial,
  ModelNode_default as ModelNode,
  ModelViewProjectionNode_default as ModelViewProjectionNode,
  MorphNode_default as MorphNode,
  Node_default as Node,
  NodeAttribute_default as NodeAttribute,
  NodeBuilder_default as NodeBuilder,
  NodeCache_default as NodeCache,
  NodeCode_default as NodeCode,
  NodeFrame_default as NodeFrame,
  NodeFunctionInput_default as NodeFunctionInput,
  NodeKeywords_default as NodeKeywords,
  NodeLoader_default as NodeLoader,
  NodeMaterial_default as NodeMaterial,
  NodeMaterialLoader_default as NodeMaterialLoader,
  NodeObjectLoader_default as NodeObjectLoader,
  NodeShaderStage,
  NodeType,
  NodeUniform_default as NodeUniform,
  NodeUpdateType,
  NodeUtils_exports as NodeUtils,
  NodeVar_default as NodeVar,
  NodeVarying_default as NodeVarying,
  NormalMapNode_default as NormalMapNode,
  NormalNode_default as NormalNode,
  Object3DNode_default as Object3DNode,
  OperatorNode_default as OperatorNode,
  OscNode_default as OscNode,
  OutputStructNode_default as OutputStructNode,
  PackingNode_default as PackingNode,
  ParameterNode_default as ParameterNode,
  PhongLightingModel_default as PhongLightingModel,
  PhysicalLightingModel_default as PhysicalLightingModel,
  PointLightNode_default as PointLightNode,
  PointUVNode_default as PointUVNode,
  PointsNodeMaterial_default as PointsNodeMaterial,
  PositionNode_default as PositionNode,
  PosterizeNode_default as PosterizeNode,
  PropertyNode_default as PropertyNode,
  RangeNode_default as RangeNode,
  ReferenceNode_default as ReferenceNode,
  ReflectVectorNode_default as ReflectVectorNode,
  RemapNode_default as RemapNode,
  RotateUVNode_default as RotateUVNode,
  SceneNode_default as SceneNode,
  Schlick_to_F0_default as Schlick_to_F0,
  ScriptableNode_default as ScriptableNode,
  ScriptableValueNode_default as ScriptableValueNode,
  SetNode_default as SetNode,
  ShaderNode,
  SkinningNode_default as SkinningNode,
  SpecularMIPLevelNode_default as SpecularMIPLevelNode,
  SplitNode_default as SplitNode,
  SpotLightNode_default as SpotLightNode,
  SpriteNodeMaterial_default as SpriteNodeMaterial,
  SpriteSheetUVNode_default as SpriteSheetUVNode,
  StackNode_default as StackNode,
  StorageBufferNode_default as StorageBufferNode,
  TBNViewMatrix,
  TangentNode_default as TangentNode,
  TempNode_default as TempNode,
  TextureBicubicNode_default as TextureBicubicNode,
  TextureNode_default as TextureNode,
  TextureStoreNode_default as TextureStoreNode,
  TimerNode_default as TimerNode,
  ToneMappingNode_default as ToneMappingNode,
  TriplanarTexturesNode_default as TriplanarTexturesNode,
  UVNode_default as UVNode,
  UniformGroupNode_default as UniformGroupNode,
  UniformNode_default as UniformNode,
  UserDataNode_default as UserDataNode,
  V_GGX_SmithCorrelated_default as V_GGX_SmithCorrelated,
  VarNode_default as VarNode,
  VaryingNode_default as VaryingNode,
  ViewportDepthNode_default as ViewportDepthNode,
  ViewportDepthTextureNode_default as ViewportDepthTextureNode,
  ViewportNode_default as ViewportNode,
  ViewportSharedTextureNode_default as ViewportSharedTextureNode,
  ViewportTextureNode_default as ViewportTextureNode,
  abs,
  acos,
  add,
  addLightNode,
  addNodeClass,
  addNodeElement,
  addNodeMaterial,
  and,
  append,
  arrayBuffer,
  asin,
  assign,
  atan,
  atan2,
  attribute,
  backgroundBlurriness,
  backgroundIntensity,
  bitAnd,
  bitOr,
  bitXor,
  bitangentGeometry,
  bitangentLocal,
  bitangentView,
  bitangentWorld,
  bmat3,
  bmat4,
  bool,
  buffer,
  bufferAttribute,
  bumpMap,
  burn,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  cache,
  call,
  cameraFar,
  cameraLogDepth,
  cameraNear,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraViewMatrix,
  cameraWorldMatrix,
  ceil,
  checker,
  clamp,
  clearcoat,
  clearcoatRoughness,
  code,
  color,
  colorSpaceToLinear,
  colorToDirection,
  compute,
  cond,
  context,
  convert,
  cos,
  createNodeFromType,
  createNodeMaterialFromType,
  cross,
  cubeTexture,
  dFdx,
  dFdy,
  dashSize,
  defaultBuildStages,
  defaultShaderStages,
  degrees,
  densityFog,
  depth,
  depthPixel,
  depthTexture,
  difference,
  diffuseColor,
  directionToColor,
  discard,
  distance,
  div,
  dodge,
  dot,
  dynamicBufferAttribute,
  element,
  equal,
  equirectUV,
  exp,
  exp2,
  expression,
  faceDirection,
  faceForward,
  float,
  floor,
  fog,
  fract,
  frameGroup,
  frameId,
  frontFacing,
  fwidth,
  gapSize,
  getConstNodeType,
  getCurrentStack,
  getDistanceAttenuation,
  getGeometryRoughness_default as getGeometryRoughness,
  getRoughness_default as getRoughness,
  global,
  glsl,
  glslFn,
  greaterThan,
  greaterThanEqual,
  hash,
  hue,
  imat3,
  imat4,
  instance,
  instanceIndex,
  instancedBufferAttribute,
  instancedDynamicBufferAttribute,
  int,
  inverseSqrt,
  iridescence,
  iridescenceIOR,
  iridescenceThickness,
  ivec2,
  ivec3,
  ivec4,
  js,
  label,
  length,
  lessThan,
  lessThanEqual,
  lightNodes,
  lightTargetDirection,
  lightingContext,
  lights,
  linearToColorSpace,
  linearTosRGB,
  log,
  log2,
  loop,
  lumaCoeffs,
  luminance,
  mat3,
  mat4,
  matcapUV,
  materialAlphaTest,
  materialClearcoat,
  materialClearcoatNormal,
  materialClearcoatRoughness,
  materialColor,
  materialEmissive,
  materialIridescence,
  materialIridescenceIOR,
  materialIridescenceThickness,
  materialLineDashOffset,
  materialLineDashSize,
  materialLineGapSize,
  materialLineScale,
  materialLineWidth,
  materialMetalness,
  materialNormal,
  materialOpacity,
  materialPointWidth,
  materialReference,
  materialReflectivity,
  materialRotation,
  materialRoughness,
  materialSheen,
  materialSheenRoughness,
  materialShininess,
  materialSpecularColor,
  materialSpecularStrength,
  max,
  maxMipLevel,
  metalness,
  min,
  mix,
  mod,
  modelDirection,
  modelNormalMatrix,
  modelPosition,
  modelScale,
  modelViewMatrix,
  modelViewPosition,
  modelViewProjection,
  modelWorldMatrix,
  morph,
  mul,
  mx_aastep,
  mx_cell_noise_float2 as mx_cell_noise_float,
  mx_contrast,
  mx_fractal_noise_float2 as mx_fractal_noise_float,
  mx_fractal_noise_vec22 as mx_fractal_noise_vec2,
  mx_fractal_noise_vec32 as mx_fractal_noise_vec3,
  mx_fractal_noise_vec42 as mx_fractal_noise_vec4,
  mx_hsvtorgb,
  mx_noise_float,
  mx_noise_vec2,
  mx_noise_vec3,
  mx_noise_vec4,
  mx_ramplr,
  mx_ramptb,
  mx_rgbtohsv,
  mx_safepower,
  mx_splitlr,
  mx_splittb,
  mx_srgb_texture_to_lin_rec709,
  mx_transform_uv,
  mx_worley_noise_float2 as mx_worley_noise_float,
  mx_worley_noise_vec22 as mx_worley_noise_vec2,
  mx_worley_noise_vec32 as mx_worley_noise_vec3,
  negate,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjects,
  nodeProxy,
  normalGeometry,
  normalLocal,
  normalMap,
  normalView,
  normalWorld,
  normalize,
  objectDirection,
  objectGroup,
  objectNormalMatrix,
  objectPosition,
  objectScale,
  objectViewMatrix,
  objectViewPosition,
  objectWorldMatrix,
  oneMinus,
  or,
  orthographicDepthToViewZ,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  output,
  outputStruct,
  overlay,
  parameter,
  perspectiveDepthToViewZ,
  pointUV,
  pointWidth,
  positionGeometry,
  positionLocal,
  positionView,
  positionViewDirection,
  positionWorld,
  positionWorldDirection,
  posterize,
  pow,
  pow2,
  pow3,
  pow4,
  property,
  radians,
  range,
  rangeFog,
  reciprocal,
  reference,
  referenceIndex,
  reflect,
  reflectVector,
  refract,
  remainder,
  remap,
  remapClamp,
  renderGroup,
  rotateUV,
  roughness,
  round,
  sRGBToLinear,
  sampler,
  saturate,
  saturation,
  screen,
  scriptable,
  scriptableValue,
  setCurrentStack,
  shader,
  shaderStages,
  sheen,
  sheenRoughness,
  shiftLeft,
  shiftRight,
  shininess,
  sign,
  sin,
  skinning,
  smoothstep,
  specularColor,
  specularMIPLevel,
  split,
  spritesheetUV,
  sqrt,
  stack,
  step,
  storage,
  string,
  sub,
  tan,
  tangentGeometry,
  tangentLocal,
  tangentView,
  tangentWorld,
  temp,
  texture,
  textureBicubic,
  textureLoad,
  textureStore,
  timerDelta,
  timerGlobal,
  timerLocal,
  toneMapping,
  transformDirection,
  transformedBitangentView,
  transformedBitangentWorld,
  transformedClearcoatNormalView,
  transformedNormalView,
  transformedNormalWorld,
  transformedTangentView,
  transformedTangentWorld,
  triplanarTexture,
  triplanarTextures,
  trunc,
  tslFn,
  uint,
  umat3,
  umat4,
  uniform,
  uniformGroup,
  userData,
  uv,
  uvec2,
  uvec3,
  uvec4,
  varying,
  varyingProperty,
  vec2,
  vec3,
  vec4,
  vectorComponents,
  vertexIndex,
  vibrance,
  viewZToOrthographicDepth,
  viewZToPerspectiveDepth,
  viewport,
  viewportBottomLeft,
  viewportBottomRight,
  viewportCoordinate,
  viewportDepthTexture,
  viewportMipTexture,
  viewportResolution,
  viewportSharedTexture,
  viewportTexture,
  viewportTopLeft,
  viewportTopRight,
  wgsl,
  wgslFn,
  xor
};
//# sourceMappingURL=three_nodes.js.map
